<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>ELIMINATOR</title>

  <style>
    :root{
      --bg:#0f1115;
      --fg:#e9edf5;
      --muted:#a8b0bd;
      --glass: rgba(255,255,255,.06);
      --glass2: rgba(255,255,255,.08);
      --stroke: rgba(255,255,255,.10);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 18px;
      --radius2: 14px;
      --pad: 14px;
      --focusGlow: rgba(120,170,255,.16); /* discret */
      --accent: rgba(120,170,255,.25);    /* discret */
      --danger: rgba(255,255,255,.12);    /* pas rouge */
      --barbg: rgba(255,255,255,.10);
      --barfg: rgba(255,255,255,.65);
      --barfg2: rgba(255,255,255,.42);
    }

    [data-theme="light"]{
      --bg:#f4f6fb;
      --fg:#101218;
      --muted:#5d6572;
      --glass: rgba(255,255,255,.62);
      --glass2: rgba(255,255,255,.74);
      --stroke: rgba(20,22,28,.10);
      --shadow: 0 12px 30px rgba(20,22,28,.12);
      --focusGlow: rgba(90,130,255,.18);
      --accent: rgba(90,130,255,.22);
      --danger: rgba(20,22,28,.08);
      --barbg: rgba(20,22,28,.10);
      --barfg: rgba(20,22,28,.70);
      --barfg2: rgba(20,22,28,.45);
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background:
        radial-gradient(1200px 700px at 20% -10%, var(--accent), transparent 60%),
        radial-gradient(900px 600px at 110% 0%, rgba(255,255,255,.06), transparent 55%),
        var(--bg);
      color:var(--fg);
      overflow-x:hidden;
    }

    .app{
      min-height:100%;
      display:flex;
      justify-content:center;
    }

    .shell{
      width:min(980px, 100%);
      padding: 14px 14px 90px;
    }

    /* Topbar: jamais de superposition -> wrap + gaps */
    .topbar{
      position:sticky;
      top:0;
      z-index:30;
      padding: 10px 0 12px;
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
    }

    .topRow{
      display:flex;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
      gap: 10px 12px;
    }

    .leftGroup, .rightGroup{
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
      align-items:center;
    }

    .hud{
      display:flex;
      flex-wrap:wrap;
      gap: 8px 10px;
      align-items:center;
      justify-content:flex-end;
      color: var(--muted);
      font-size: 13px;
      letter-spacing: .01em;
      white-space:nowrap;
    }
    .hud .pill{
      padding: 6px 10px;
      border-radius: 999px;
      background: var(--glass);
      border: 1px solid var(--stroke);
      box-shadow: var(--shadow);
    }

    /* Boutons: monochrome, √©l√©gants */
    .btn{
      border: 1px solid var(--stroke);
      background: var(--glass);
      color: var(--fg);
      padding: 10px 12px;
      border-radius: 12px;
      box-shadow: var(--shadow);
      cursor:pointer;
      line-height:1;
      user-select:none;
      transition: transform .08s ease, background .2s ease, border-color .2s ease;
      font-weight:650;
      letter-spacing: .01em;
    }
    .btn:active{ transform: translateY(1px) }
    .btn.ghost{
      background: transparent;
      box-shadow:none;
    }
    .btn.small{
      padding: 8px 10px;
      border-radius: 10px;
      font-weight: 650;
    }
    .btn.wide{
      padding: 12px 16px;
      border-radius: 14px;
    }
    .btn.pressed{
      outline:none;
      border-color: rgba(255,255,255,.22);
      box-shadow: 0 0 0 4px var(--focusGlow), var(--shadow);
    }
    [data-theme="light"] .btn.pressed{
      border-color: rgba(20,22,28,.20);
      box-shadow: 0 0 0 4px var(--focusGlow), var(--shadow);
    }

    .main{
      margin-top: 10px;
      display:flex;
      justify-content:center;
    }

    .card{
      width:min(860px, 100%);
      border-radius: var(--radius);
      border: 1px solid var(--stroke);
      background: var(--glass2);
      box-shadow: var(--shadow);
      backdrop-filter: blur(18px);
      -webkit-backdrop-filter: blur(18px);
      padding: 18px;
    }

    /* Titre + tagline */
    .brand{
      text-align:center;
      margin: 10px 0 18px;
    }
    .brand h1{
      margin: 0;
      font-size: clamp(38px, 4.2vw, 64px);
      letter-spacing: -0.03em;
      font-weight: 920;
    }
    .brand .tag{
      margin-top: 8px;
      font-size: 14px;
      color: var(--muted);
      letter-spacing:.02em;
    }

    /* Progress zone s√©par√©e et grande */
    .progressZone{
      margin: 16px auto 10px;
      width: min(760px, 100%);
      padding: 16px 14px 14px;
      border-radius: var(--radius);
      border: 1px solid var(--stroke);
      background: var(--glass);
      box-shadow: var(--shadow);
    }

    .bigbar{
      position:relative;
      height: 34px;
      border-radius: 999px;
      background: var(--barbg);
      overflow:hidden;
    }
    .bigbar .fill{
      height:100%;
      width:50%;
      background: var(--barfg);
      transition: width .25s ease;
    }
    .bigbar .pct{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight: 850;
      letter-spacing:.02em;
      font-size: 14px;
      color: var(--fg);
      text-shadow: 0 1px 0 rgba(0,0,0,.08);
      pointer-events:none;
    }

    .targetWrap{
      margin: 18px auto 8px;
      width: min(760px, 100%);
      text-align:center;
    }

    .targetName{
      font-size: clamp(22px, 2.2vw, 30px);
      font-weight: 850;
      letter-spacing: -0.01em;
      margin: 0 0 10px;
    }

    /* barre ‚Äú√©torions‚Äù (fragments) */
    .ethBar{
      margin: 8px auto 0;
      width: min(520px, 100%);
      height: 12px;
      border-radius: 999px;
      background: var(--barbg);
      overflow:hidden;
      position:relative;
    }
    .ethBar .fill{
      height:100%;
      width:100%;
      background: var(--barfg2);
      transition: width .25s ease;
    }
    .ethTicks{
      width:min(520px,100%);
      margin: 8px auto 0;
      display:flex;
      gap: 6px;
      justify-content:center;
      opacity: .9;
      flex-wrap:wrap;
    }
    .tick{
      width: 12px;
      height: 6px;
      border-radius: 999px;
      border: 1px dashed var(--stroke);
      background: transparent;
    }
    .tick.on{
      background: var(--barfg2);
      border-style: solid;
      border-color: transparent;
    }

    /* Actions principales */
    .actions{
      margin: 18px auto 0;
      width: min(760px, 100%);
      display:flex;
      justify-content:center;
      gap: 10px;
      flex-wrap:wrap;
    }

    .rouletteBtn{
      min-width: 170px;
      padding: 14px 18px;
      border-radius: 16px;
      font-size: 16px;
    }
    .rouletteBtn.spin{
      animation: spinPulse .55s ease;
    }
    @keyframes spinPulse{
      0%{transform:scale(1)}
      50%{transform:scale(1.04)}
      100%{transform:scale(1)}
    }

    .bombBtn{
      min-width: 220px;
      padding: 16px 18px;
      border-radius: 16px;
      font-size: 16px;
    }

    /* Micro actions (pin/edit/delete/down) sous la cible */
    .micro{
      margin: 12px auto 0;
      width: min(760px, 100%);
      display:flex;
      justify-content:center;
      gap: 8px;
      flex-wrap:wrap;
      color: var(--muted);
    }

    /* Inline list */
    .inlineListWrap{
      width: min(760px, 100%);
      margin: 18px auto 0;
      padding: 12px;
      border-radius: var(--radius);
      border: 1px solid var(--stroke);
      background: var(--glass);
      box-shadow: var(--shadow);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
    }
    .inlineListHead{
      display:flex;
      justify-content:space-between;
      gap: 10px;
      align-items:center;
      margin-bottom: 10px;
    }
    .inlineListTitle{
      font-weight: 850;
      letter-spacing: -0.01em;
    }
    .list{
      display:flex;
      flex-direction:column;
      gap: 8px;
    }
    .item{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.03);
    }
    [data-theme="light"] .item{ background: rgba(20,22,28,.03); }

    .t{
      min-width:0;
      flex:1;
    }
    .name{
      font-weight: 780;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .sub{
      color: var(--muted);
      font-size: 12px;
      margin-top: 2px;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }

    .iconBtn{
      width: 34px;
      height: 34px;
      display:grid;
      place-items:center;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      background: var(--glass);
      box-shadow: var(--shadow);
      cursor:pointer;
      font-weight: 900;
      line-height:1;
      user-select:none;
    }
    .iconBtn:active{transform:translateY(1px)}

    /* Drawer */
    .drawerBack{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display:none;
      z-index:50;
    }
    [data-theme="light"] .drawerBack{ background: rgba(10,12,16,.18); }

    .drawer{
      position:fixed;
      top:0;
      bottom:0;
      left:0;
      width: min(420px, 92vw);
      background: var(--glass2);
      border-right: 1px solid var(--stroke);
      box-shadow: var(--shadow);
      backdrop-filter: blur(18px);
      -webkit-backdrop-filter: blur(18px);
      transform: translateX(-105%);
      transition: transform .22s ease;
      z-index:60;
      padding: 14px;
      display:flex;
      flex-direction:column;
      gap: 12px;
    }
    .drawer.open{ transform: translateX(0) }
    .drawerTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .tabs{
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
    }
    .tab{
      padding: 10px 12px;
      border-radius: 999px;
      border:1px solid var(--stroke);
      background: var(--glass);
      cursor:pointer;
      font-weight: 750;
      font-size: 13px;
      box-shadow: var(--shadow);
    }
    .tab.active{
      box-shadow: 0 0 0 4px var(--focusGlow), var(--shadow);
    }
    .view{
      flex:1;
      overflow:auto;
      padding-right: 4px;
    }
    .section{
      border:1px solid var(--stroke);
      background: var(--glass);
      border-radius: var(--radius2);
      padding: 12px;
      box-shadow: var(--shadow);
      margin-bottom: 10px;
    }
    .section h3{
      margin: 0 0 10px;
      font-size: 14px;
      letter-spacing:.01em;
    }
    .help{
      color: var(--muted);
      font-size: 13px;
      margin: 8px 0 0;
      line-height:1.4;
    }
    textarea, input, select{
      width:100%;
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.04);
      color: var(--fg);
      border-radius: 12px;
      padding: 10px 12px;
      font: inherit;
      outline:none;
    }
    [data-theme="light"] textarea,
    [data-theme="light"] input,
    [data-theme="light"] select{
      background: rgba(20,22,28,.04);
    }

    .row{
      display:flex;
      gap: 8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .row > *{ flex: 1 }
    .row .btn, .row .iconBtn{ flex: 0 0 auto }

    /* Notes modal */
    .modalBack{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.35);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      display:none;
      z-index:80;
    }
    [data-theme="light"] .modalBack{ background: rgba(10,12,16,.18); }

    .modal{
      position:fixed;
      inset: 10% 50% auto 50%;
      transform: translateX(-50%);
      width: min(720px, 94vw);
      background: var(--glass2);
      border:1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
      display:none;
      z-index:90;
    }
    .modalTop{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 10px;
      margin-bottom: 10px;
    }

    /* Celebration overlay */
    .celeBack{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.35);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      display:none;
      z-index:100;
    }
    [data-theme="light"] .celeBack{ background: rgba(10,12,16,.16); }

    .cele{
      position:fixed;
      inset: 18% 50% auto 50%;
      transform: translateX(-50%);
      width: min(760px, 94vw);
      border-radius: var(--radius);
      border:1px solid var(--stroke);
      background: var(--glass2);
      box-shadow: var(--shadow);
      padding: 18px;
      display:none;
      z-index:110;
      text-align:center;
    }
    .celeTitle{
      font-weight: 920;
      letter-spacing: -0.02em;
      font-size: clamp(24px, 2.4vw, 34px);
      margin: 0 0 10px;
    }
    .celeMsg{
      color: var(--muted);
      font-size: 15px;
      line-height:1.5;
      margin: 0 auto 14px;
      width: min(640px, 100%);
    }

    /* Confetti canvas */
    #confetti{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index:120;
      display:none;
    }

    /* Focus mode: masque presque tout sauf essentials */
    .focus .drawerBack,
    .focus .drawer,
    .focus .inlineListWrap,
    .focus .micro{
      display:none !important;
    }

    /* Responsive: topbar -> tout wrap naturellement */
    @media (max-width: 520px){
      .hud{ justify-content:flex-start; }
      .rouletteBtn{ min-width: 150px; }
      .bombBtn{ min-width: 200px; }
      .progressZone{ padding: 14px 12px; }
    }
  </style>
</head>

<body data-theme="light">
  <canvas id="confetti"></canvas>

  <div class="drawerBack" id="drawerBack"></div>
  <aside class="drawer" id="drawer">
    <div class="drawerTop">
      <div style="font-weight:900; letter-spacing:-0.02em;">Menu</div>
      <button class="btn small" id="btnCloseDrawer">Fermer</button>
    </div>

    <div class="tabs" id="tabs"></div>

    <div class="view" id="drawerView"></div>
  </aside>

  <div class="modalBack" id="notesBack"></div>
  <div class="modal" id="notesModal">
    <div class="modalTop">
      <div style="font-weight:900; letter-spacing:-0.02em;">Notes</div>
      <button class="btn small" id="btnCloseNotes">Fermer</button>
    </div>
    <div class="section">
      <h3>Nouvelle note (persistante)</h3>
      <textarea id="noteInput" rows="3" placeholder="√âcris. √áa reste. M√™me apr√®s reset."></textarea>
      <div class="row" style="margin-top:10px;">
        <button class="btn" id="btnAddNote">Ajouter</button>
        <button class="btn ghost" id="btnClearNotes">Vider (irr√©versible)</button>
      </div>
      <p class="help">Les notes sont sauvegard√©es dans la m√©moire locale de l‚Äôapp.</p>
    </div>

    <div class="section">
      <h3>Historique des notes</h3>
      <div class="list" id="notesList"></div>
    </div>
  </div>

  <div class="celeBack" id="celeBack"></div>
  <div class="cele" id="celeModal">
    <div class="celeTitle" id="celeTitle">Victoire</div>
    <div class="celeMsg" id="celeMsg">...</div>
    <button class="btn" id="btnCloseCele">OK</button>
    <p class="help" id="celeHint" style="margin-top:10px;">(Cette c√©l√©bration peut dispara√Ætre automatiquement.)</p>
  </div>

  <div class="app">
    <div class="shell">
      <div class="topbar">
        <div class="topRow">
          <div class="leftGroup">
            <button class="btn" id="btnMenu">Menu</button>
            <button class="btn" id="btnTheme">Th√®me</button>
            <button class="btn" id="btnFocus">Focus</button>
            <button class="btn" id="btnInlineList">Liste</button>
            <button class="btn" id="btnReset">Reset</button>
          </div>

          <div class="rightGroup">
            <div class="hud" id="hud"></div>
          </div>
        </div>
      </div>

      <div class="main">
        <div class="card" id="card">
          <div class="brand">
            <h1>ELIMINATOR</h1>
            <div class="tag">D√©gomme toutes les t√¢ches. D√©gomme tous les √©torions en cours.</div>
          </div>

          <div class="progressZone">
            <div class="bigbar" aria-label="progression t√¢ches">
              <div class="fill" id="taskFill"></div>
              <div class="pct" id="taskPct">0%</div>
            </div>
          </div>

          <div class="targetWrap">
            <div class="targetName" id="currentTitle">Aucune t√¢che</div>
            <div class="ethBar" aria-label="progression √©torions">
              <div class="fill" id="ethFill"></div>
            </div>
            <div class="ethTicks" id="ethTicks"></div>
          </div>

          <div class="micro" id="microActions">
            <button class="btn small" id="btnPin">√âpingler</button>
            <button class="btn small" id="btnEdit">√âditer</button>
            <button class="btn small" id="btnDown">Descendre</button>
            <button class="btn small" id="btnDone">Marquer d√©gomm√©e</button>
            <button class="btn small" id="btnDel">Supprimer</button>
          </div>

          <div class="actions">
            <button class="btn wide rouletteBtn" id="btnRoulette">Roulette</button>
            <button class="btn wide bombBtn" id="btnDegomme">üí£ D√©gommer 1 √©torion</button>
            <button class="btn wide" id="btnNotes">Notes</button>
          </div>

          <div class="inlineListWrap" id="inlineListWrap" style="display:none;">
            <div class="inlineListHead">
              <div class="inlineListTitle">T√¢ches en cours</div>
              <div class="row" style="justify-content:flex-end;">
                <button class="btn small" id="btnInlineListHide">Masquer</button>
              </div>
            </div>
            <div class="list" id="inlineTaskList"></div>
          </div>

        </div>
      </div>
    </div>
  </div>

  <script>
    // =========================
    // Storage keys
    // =========================
    const KEY_STATE = "elim_state_v2";
    const KEY_SETTINGS = "elim_settings_v2";
    const KEY_NOTES = "elim_notes_v2";
    const KEY_KIFF = "elim_kiffbank_v2";
    const KEY_HABITS = "elim_habits_v2";

    // =========================
    // Helpers
    // =========================
    const el = (id)=>document.getElementById(id);
    const nowISO = ()=> new Date().toISOString();
    const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
    const pad2 = (n)=>String(n).padStart(2,"0");
    const fmtTime = (ms)=>{
      const s = Math.floor(ms/1000);
      const m = Math.floor(s/60);
      const r = s%60;
      return `${m}:${pad2(r)}`;
    };
    const rand = (n)=>Math.floor(Math.random()*n);
    const uniq = ()=>Math.random().toString(16).slice(2)+Date.now().toString(16);

    function downloadText(filename, text){
      const blob = new Blob([text], {type:"text/plain;charset=utf-8"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // =========================
    // Data models
    // =========================
    const DEFAULTS_SETTINGS = {
      theme: "light",       // light default
      focus: 0,
      inlineListVisible: 0,
      // surprise celebrations
      fatigue: 2,           // 0..4
      motivation: 2,        // 0..4
      celeChanceBase: 0.22, // base probability per task completion
      celeAutoCloseSec: 10,
      // filtering categories
      activeCats: ["INBOX"], // if empty => all
      // roulette mode
      rouletteMode: "random", // random | ordered
      // ordered strategy
      orderedStrategy: "pinnedFirst", // pinnedFirst | alpha | chrono
    };

    const DEFAULT_STATE = {
      tasks: [],
      done: [],      // completed tasks archive (today + past)
      currentId: null,
      startCounts: { tasks:0, eth:0 }, // baseline for session
      timer: { taskId:null, elapsedMs:0, running:false, startedAt:0 },
      history: [],   // daily snapshots
      lastSaveDay: "", // YYYY-MM-DD for daily rollover
      streak: { completedSinceCele: 0 }
    };

    // =========================
    // UI refs
    // =========================
    const btnMenu = el("btnMenu");
    const btnTheme = el("btnTheme");
    const btnFocus = el("btnFocus");
    const btnInlineList = el("btnInlineList");
    const btnInlineListHide = el("btnInlineListHide");
    const btnReset = el("btnReset");

    const hud = el("hud");
    const taskFill = el("taskFill");
    const taskPct = el("taskPct");
    const currentTitle = el("currentTitle");
    const ethFill = el("ethFill");
    const ethTicks = el("ethTicks");

    const btnRoulette = el("btnRoulette");
    const btnDegomme = el("btnDegomme");
    const btnNotes = el("btnNotes");

    const btnPin = el("btnPin");
    const btnEdit = el("btnEdit");
    const btnDown = el("btnDown");
    const btnDone = el("btnDone");
    const btnDel = el("btnDel");

    const inlineListWrap = el("inlineListWrap");
    const inlineTaskList = el("inlineTaskList");

    const drawerBack = el("drawerBack");
    const drawer = el("drawer");
    const btnCloseDrawer = el("btnCloseDrawer");
    const tabsEl = el("tabs");
    const drawerView = el("drawerView");

    const notesBack = el("notesBack");
    const notesModal = el("notesModal");
    const btnCloseNotes = el("btnCloseNotes");
    const noteInput = el("noteInput");
    const btnAddNote = el("btnAddNote");
    const btnClearNotes = el("btnClearNotes");
    const notesList = el("notesList");

    const celeBack = el("celeBack");
    const celeModal = el("celeModal");
    const celeTitle = el("celeTitle");
    const celeMsg = el("celeMsg");
    const btnCloseCele = el("btnCloseCele");

    const confettiCanvas = el("confetti");
    const ctx = confettiCanvas.getContext("2d");

    // =========================
    // State
    // =========================
    let settings = load(KEY_SETTINGS, DEFAULTS_SETTINGS);
    let state = load(KEY_STATE, DEFAULT_STATE);
    let notes = load(KEY_NOTES, []);
    let kiffBank = load(KEY_KIFF, null);
    let habits = load(KEY_HABITS, []);

    // =========================
    // Init kiff bank (√©norme + cat√©goris√©e)
    // =========================
    function initKiffBank(){
      // 4 cat√©gories: 5m, 10m, 15m, 25m+
      // Banque volontairement tr√®s large et ‚Äúpr√™te √† l‚Äôemploi‚Äù
      return {
        v: 1,
        buckets: {
          "5m": [
            "Respiration carr√©e 4-4-4-4 pendant 2 minutes.",
            "Ranger une surface (une seule) : table, bureau, √©vier.",
            "Boire un verre d‚Äôeau. Lentement. Comme un rituel d‚Äôempire.",
            "√âtirement nuque/√©paules 90 secondes.",
            "Relire la prochaine micro-√©tape de ta t√¢che (juste la prochaine).",
            "Fermer 3 onglets qui ne servent √† rien. Ex√©cution propre.",
            "Mini marche : 200 pas dans la pi√®ce, sans t√©l√©phone.",
            "Nettoyer l‚Äô√©cran (oui, l‚Äô√©cran).",
            "√âcrire 1 phrase : ‚ÄúL√†, je fais X.‚Äù",
            "Mettre un timer 5 min et faire ‚Äúle d√©but moche‚Äù."
          ],
          "10m": [
            "Marche rapide 8 minutes, retour 2 minutes.",
            "Pr√©parer un snack simple et neutre (pas une ≈ìuvre d‚Äôart).",
            "D√©gager 10 items : jeter / ranger / classer.",
            "Douche express ou visage/eau froide 60 secondes + retour calme.",
            "√âcrire un mini plan : 3 puces max.",
            "R√©viser un paragraphe / une page, sans chercher la perfection.",
            "Ranger la zone ‚Äúinbox‚Äù (mail/notes) pendant 10 minutes puis stop.",
            "√âtirements dos + hanches 10 minutes.",
            "Faire une petite check de planning (juste la prochaine heure).",
            "Pr√©parer ‚Äúkit de reprise‚Äù : eau + stylo + page ouverte."
          ],
          "15m": [
            "Pause de marche 12 min + 3 min de respiration lente.",
            "Micro s√©ance mobilit√© (cou/√©paules/hanches) 15 min.",
            "Pr√©parer une liste de 5 t√¢ches pour demain (pas plus).",
            "Lecture plaisir 10 min + 5 min de retour √† la t√¢che.",
            "Ranger un tiroir (un seul) ‚Äî fin quand le timer sonne.",
            "Pr√©parer un espace de travail ultra propre (15 minutes chrono).",
            "Faire 15 minutes de ‚Äúbrouillon‚Äù sur un document p√©nible.",
            "Exercices de gainage l√©ger 10 min + √©tirements 5 min.",
            "Mettre √† jour une seule section d‚Äôun dossier/rapport.",
            "Appeler / message une personne utile (1 seul message)."
          ],
          "25m+": [
            "Sortie courte : marche + air + retour (30 min).",
            "Session de deep-clean d‚Äôune zone (25 min) puis arr√™t net.",
            "S√©ance sport l√©g√®re/mod√©r√©e 30-40 min.",
            "Cuisine simple pour 2 repas (batch minimaliste).",
            "Revue hebdo (30 min) : ce qui reste, ce qui part, ce qui compte.",
            "Lecture cibl√©e + prise de notes (25 min).",
            "R√©organisation d‚Äôun set (h√¥pital/consult) + plan du lendemain.",
            "√âcrire une page ‚Äúd√©charge mentale‚Äù puis classer 3 actions.",
            "Faire une t√¢che admin lourde 25 min, stop, c√©l√©bration int√©rieure.",
            "Pr√©parer un environnement ‚Äúflow‚Äù (lumi√®re, sons off, distractions out)."
          ]
        }
      };
    }
    if(!kiffBank || !kiffBank.buckets){
      kiffBank = initKiffBank();
      save(KEY_KIFF, kiffBank);
    }

    // =========================
    // Drawer Tabs + Views
    // =========================
    const TAB_DEFS = [
      { key:"inbox",   label:"Inbox" },
      { key:"liste",   label:"Liste" },
      { key:"cats",    label:"Cat" },
      { key:"sets",    label:"Sets" },
      { key:"mode",    label:"Mode" },
      { key:"energie", label:"√ânergie" },
      { key:"params",  label:"Param" },
      { key:"profiles",label:"Profils" },
      { key:"banks",   label:"Textes" },
      { key:"kiff",    label:"Kiffance" },
      { key:"calib",   label:"Calib" },
      { key:"hist",    label:"Hist" },
      { key:"rapport", label:"Rapport" }
    ];

    let activeTab = "inbox";

    // =========================
    // Load/Save
    // =========================
    function load(key, fallback){
      try{
        const raw = localStorage.getItem(key);
        if(!raw) return structuredClone(fallback);
        return Object.assign(structuredClone(fallback), JSON.parse(raw));
      }catch{
        return structuredClone(fallback);
      }
    }
    function save(key, obj){
      localStorage.setItem(key, JSON.stringify(obj));
    }
    function persistAll(){
      save(KEY_SETTINGS, settings);
      save(KEY_STATE, state);
      save(KEY_NOTES, notes);
      save(KEY_HABITS, habits);
      save(KEY_KIFF, kiffBank);
    }

    // =========================
    // Day rollover + history
    // =========================
    function dayKey(d=new Date()){
      return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
    }

    function rolloverIfNeeded(){
      const today = dayKey();
      if(!state.lastSaveDay){
        state.lastSaveDay = today;
        persistAll();
        return;
      }
      if(state.lastSaveDay !== today){
        // snapshot previous day
        state.history.push(buildDailySnapshot(state.lastSaveDay));
        // keep history reasonable
        if(state.history.length > 180) state.history = state.history.slice(-180);
        // reset only the daily counters if you want; here we just update day marker
        state.lastSaveDay = today;
        persistAll();
      }
    }

    function buildDailySnapshot(day){
      const doneThatDay = state.done.filter(x => (x.doneAt||"").startsWith(day));
      const totalDone = doneThatDay.length;
      const ethDone = doneThatDay.reduce((a,t)=>a+(t.ethStart||0),0);
      return {
        day,
        totalDone,
        ethDone,
        remainingTasks: state.tasks.length,
        remainingEth: state.tasks.reduce((a,t)=>a+(t.ethLeft||0),0),
        habits: habits.map(h=>({
          name: h.name,
          total: h.total,
          checked: h.checked || 0
        }))
      };
    }

    // =========================
    // Theme + focus
    // =========================
    function applyTheme(){
      document.body.setAttribute("data-theme", settings.theme);
      btnTheme.classList.toggle("pressed", settings.theme==="light");
    }
    function applyFocus(){
      document.body.classList.toggle("focus", !!settings.focus);
      btnFocus.classList.toggle("pressed", !!settings.focus);
    }

    // =========================
    // Tasks
    // =========================
    function computeStartCountsIfEmpty(){
      if(!state.startCounts || state.startCounts.tasks===0 && state.startCounts.eth===0){
        state.startCounts = {
          tasks: state.tasks.length,
          eth: state.tasks.reduce((a,t)=>a+(t.ethStart||0),0)
        };
      }
    }

    function ensureCurrent(){
      if(state.currentId && state.tasks.some(t=>t.id===state.currentId)) return;
      // prefer pinned tasks
      const pinned = state.tasks.find(t=>t.pinned);
      const next = pinned || state.tasks[0] || null;
      state.currentId = next ? next.id : null;
    }

    function currentTask(){
      return state.tasks.find(t=>t.id===state.currentId) || null;
    }

    function filteredTasks(){
      // activeCats empty => all
      if(!settings.activeCats || settings.activeCats.length===0) return state.tasks;
      return state.tasks.filter(t => settings.activeCats.includes((t.cat||"INBOX")));
    }

    function pickRoulette(){
      const pool = filteredTasks();
      if(!pool.length) return null;

      if(settings.rouletteMode === "ordered"){
        const ordered = [...pool];
        if(settings.orderedStrategy === "pinnedFirst"){
          ordered.sort((a,b)=>(b.pinned?1:0)-(a.pinned?1:0) || (a.createdAt||"").localeCompare(b.createdAt||""));
        }else if(settings.orderedStrategy === "alpha"){
          ordered.sort((a,b)=>(a.title||"").localeCompare(b.title||"", "fr", {sensitivity:"base"}));
        }else{
          ordered.sort((a,b)=>(a.createdAt||"").localeCompare(b.createdAt||""));
        }
        return ordered[0];
      }else{
        return pool[rand(pool.length)];
      }
    }

    function setCurrent(id){
      state.currentId = id;
      // restart timer for current task
      state.timer = { taskId:id, elapsedMs:0, running:true, startedAt: Date.now() };
      persistAll();
      renderAll();
    }

    function tickTimer(){
      const t = state.timer;
      if(!t || !t.running || !t.taskId) return;
      const now = Date.now();
      t.elapsedMs += (now - (t.startedAt || now));
      t.startedAt = now;
    }

    function makeTask(title, cat="INBOX", eth=1, prio=0){
      const e = clamp(parseInt(eth||1,10) || 1, 1, 999);
      return {
        id: uniq(),
        title: (title||"").trim(),
        cat,
        ethStart: e,
        ethLeft: e,
        prio: prio ? 1 : 0,
        pinned: false,
        createdAt: nowISO(),
        updatedAt: nowISO()
      };
    }

    function deleteTask(id){
      const idx = state.tasks.findIndex(t=>t.id===id);
      if(idx<0) return;
      const wasCurrent = state.currentId===id;
      state.tasks.splice(idx,1);
      if(wasCurrent) state.currentId=null;
      ensureCurrent();
      persistAll();
      renderAll();
    }

    function markDone(id){
      const idx = state.tasks.findIndex(t=>t.id===id);
      if(idx<0) return;
      const t = state.tasks[idx];
      t.doneAt = nowISO();
      state.done.push(t);
      state.tasks.splice(idx,1);
      state.streak.completedSinceCele = (state.streak.completedSinceCele||0) + 1;

      // confetti always at task completion
      burstConfetti();

      // celebration occasionally (surprise)
      maybeCelebrate(t);

      if(state.currentId===id) state.currentId=null;
      ensureCurrent();
      computeStartCountsIfEmpty();
      persistAll();
      renderAll();
    }

    function degommeOneEth(){
      const t = currentTask();
      if(!t) return;

      // update timer tick first
      tickTimer();

      t.ethLeft = Math.max(0, (t.ethLeft||0) - 1);
      t.updatedAt = nowISO();

      // when eth reaches 0 => task done
      if(t.ethLeft===0){
        markDone(t.id);
        return;
      }

      persistAll();
      renderAll();
    }

    function pinToggle(){
      const t = currentTask();
      if(!t) return;
      t.pinned = !t.pinned;
      t.updatedAt = nowISO();
      persistAll();
      renderAll();
    }

    function pushDownCurrent(){
      const t = currentTask();
      if(!t) return;
      const idx = state.tasks.findIndex(x=>x.id===t.id);
      if(idx<0) return;
      state.tasks.splice(idx,1);
      state.tasks.push(t);
      persistAll();
      renderAll();
    }

    function moveTask(taskId, delta){
      const idx = state.tasks.findIndex(x=>x.id===taskId);
      if(idx < 0) return;
      const j = idx + delta;
      if(j < 0 || j >= state.tasks.length) return;
      const tmp = state.tasks[j];
      state.tasks[j] = state.tasks[idx];
      state.tasks[idx] = tmp;
      persistAll();
      renderAll();
      renderPanel();
    }

    function editTaskTitle(id, newTitle){
      const t = state.tasks.find(x=>x.id===id);
      if(!t) return;
      t.title = (newTitle||"").trim() || t.title;
      t.updatedAt = nowISO();
      persistAll();
      renderAll();
    }

    // =========================
    // Inbox parsing (MAJUSCULES = cat√©gorie)
    //  - LIGNES sous la cat√©gorie => t√¢ches
    //  - format t√¢che: "Nom - 3" => eth=3
    //  - priorit√©: si contient "!": prio=1 (optionnel)
    // =========================
    function parseInbox(text){
      const lines = (text||"").split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
      let cat = "INBOX";
      const tasks = [];
      for(const line of lines){
        // category header: all caps & not too long
        if(isCategoryHeader(line)){
          cat = normalizeCat(line);
          continue;
        }
        // parse eth
        let title = line;
        let eth = 1;
        let prio = 0;

        // priority marker optional
        if(title.includes("!")){
          prio = 1;
          title = title.replace(/!/g,"").trim();
        }

        // eth patterns: " - 3" OR " 3" at end
        const m1 = title.match(/^(.*?)(?:\s*[-‚Äì‚Äî]\s*)(\d{1,3})$/);
        const m2 = title.match(/^(.*?)(?:\s+)(\d{1,3})$/);
        if(m1){
          title = m1[1].trim();
          eth = parseInt(m1[2],10);
        }else if(m2){
          // only if last token is number and title part non-empty
          if(m2[1].trim().length>0){
            title = m2[1].trim();
            eth = parseInt(m2[2],10);
          }
        }

        if(!title) continue;
        tasks.push(makeTask(title, cat, eth, prio));
      }
      return tasks;
    }

    function isCategoryHeader(line){
      // consider header if mostly uppercase letters/spaces and length between 3..40
      if(line.length<3 || line.length>40) return false;
      // ignore lines that look like tasks with numbers
      if(/\d/.test(line)) return false;
      const hasLetter = /[A-Z√Ä-√ñ√ò-√ù]/.test(line);
      if(!hasLetter) return false;
      const upperish = line === line.toUpperCase();
      return upperish;
    }

    function normalizeCat(s){
      return (s||"").trim().toUpperCase();
    }

    // =========================
    // Notes
    // =========================
    function openNotes(){
      notesBack.style.display = "block";
      notesModal.style.display = "block";
      renderNotes();
    }
    function closeNotes(){
      notesBack.style.display = "none";
      notesModal.style.display = "none";
    }
    function addNote(){
      const txt = (noteInput.value||"").trim();
      if(!txt) return;
      notes.unshift({ id: uniq(), at: nowISO(), text: txt });
      noteInput.value = "";
      persistAll();
      renderNotes();
    }
    function renderNotes(){
      notesList.innerHTML = "";
      if(!notes.length){
        const p = document.createElement("p");
        p.className="help";
        p.textContent="Aucune note.";
        notesList.appendChild(p);
        return;
      }
      for(const n of notes){
        const row = document.createElement("div");
        row.className="item";
        const left = document.createElement("div");
        left.className="t";
        const name = document.createElement("div");
        name.className="name";
        name.textContent = new Date(n.at).toLocaleString();
        const sub = document.createElement("div");
        sub.className="sub";
        sub.textContent = n.text;
        left.appendChild(name); left.appendChild(sub);

        const del = document.createElement("button");
        del.className="iconBtn";
        del.textContent="‚úï";
        del.title="Supprimer";
        del.onclick = ()=>{
          notes = notes.filter(x=>x.id!==n.id);
          persistAll();
          renderNotes();
        };

        row.appendChild(left);
        row.appendChild(del);
        notesList.appendChild(row);
      }
    }

    // =========================
    // Habits (suivi)
    // =========================
    function addHabit(name, total=10){
      const n = (name||"").trim();
      if(!n) return;
      const t = clamp(parseInt(total,10)||10, 1, 30);
      habits.push({ id: uniq(), name:n, total:t, checked:0, createdAt: nowISO() });
      persistAll();
      renderPanel();
    }

    function habitToggle(id, idx){
      const h = habits.find(x=>x.id===id);
      if(!h) return;
      // toggle bit at position idx (0..total-1) using integer count only (simple)
      // We'll implement as count-based: clicking one of the boxes sets checked = idx+1 if bigger; else idx
      const target = idx+1;
      h.checked = (h.checked===target) ? idx : target;
      h.checked = clamp(h.checked, 0, h.total);
      persistAll();
      renderPanel();
    }

    function habitReset(id){
      const h = habits.find(x=>x.id===id);
      if(!h) return;
      h.checked = 0;
      persistAll();
      renderPanel();
    }

    function habitDelete(id){
      habits = habits.filter(x=>x.id!==id);
      persistAll();
      renderPanel();
    }

    // =========================
    // Celebration (surprise) + phrases
    // =========================
    const CELE_POOL = [
      {t:"Triomphe", m:"Tu viens de gagner une bataille contre l‚Äôentropie. L‚Äôunivers a grogn√©. Tu as continu√©."},
      {t:"Conqu√™te", m:"Tu as pris une forteresse. Les papiers administratifs se sont rendus sans condition."},
      {t:"Gloire", m:"Un √©torion a chut√©. Les l√©gendes prennent des notes."},
      {t:"Domination", m:"La t√¢che a pli√©. Tu es officiellement un √©v√©nement historique."},
      {t:"Victoire", m:"Le chaos a tent√© un coup d‚Äô√âtat. Tu as r√©pondu par un geste calme et pr√©cis."},
      {t:"Supr√©matie", m:"Les procrastinations ont fui. Elles se regroupent probablement ailleurs. Tant pis pour elles."},
      {t:"√âpop√©e", m:"Un chapitre de plus dans ta saga. L‚Äôarchiviste des h√©ros hoche la t√™te."},
      {t:"Souverainet√©", m:"Tu as repris du territoire mental. Fronti√®re s√©curis√©e. Drapeau plant√©."},
      {t:"Ascension", m:"Tu montes. C‚Äôest pas spectaculaire. C‚Äôest mieux : c‚Äôest solide."},
      {t:"Art martial", m:"Tu as frapp√© exactement au bon endroit : la prochaine action."}
    ];

    function celebrationProbability(){
      // plus fatigu√©e => un peu plus de chance (soutien)
      // plus motiv√©e => un peu moins (surprise rare)
      const f = clamp(settings.fatigue,0,4);
      const m = clamp(settings.motivation,0,4);
      let p = settings.celeChanceBase;
      p += (f-2)*0.04;
      p -= (m-2)*0.03;
      // also throttle: show roughly every 2-4 tasks
      const streak = state.streak.completedSinceCele||0;
      if(streak < 2) p *= 0.35;
      if(streak >= 3) p *= 1.2;
      return clamp(p, 0.02, 0.60);
    }

    function maybeCelebrate(task){
      const p = celebrationProbability();
      if(Math.random() > p) return;
      // reset streak
      state.streak.completedSinceCele = 0;
      showCelebration();
    }

    let celeTimer = null;
    function showCelebration(){
      const pick = CELE_POOL[rand(CELE_POOL.length)];
      celeTitle.textContent = pick.t;
      celeMsg.textContent = pick.m;

      celeBack.style.display = "block";
      celeModal.style.display = "block";

      // auto close
      const sec = clamp(parseInt(settings.celeAutoCloseSec,10)||10, 4, 20);
      if(celeTimer) clearTimeout(celeTimer);
      celeTimer = setTimeout(()=>closeCelebration(), sec*1000);
      persistAll();
    }

    function closeCelebration(){
      celeBack.style.display = "none";
      celeModal.style.display = "none";
      if(celeTimer) clearTimeout(celeTimer);
      celeTimer = null;
    }

    // =========================
    // Confetti (monochrome)
    // =========================
    let confetti = [];
    function burstConfetti(){
      const w = confettiCanvas.width = window.innerWidth;
      const h = confettiCanvas.height = window.innerHeight;
      confettiCanvas.style.display="block";
      confetti = [];
      const n = 120;
      for(let i=0;i<n;i++){
        confetti.push({
          x: w/2 + (Math.random()-0.5)*180,
          y: h*0.28 + (Math.random()-0.5)*60,
          vx: (Math.random()-0.5)*6,
          vy: -Math.random()*6 - 2,
          g: 0.18 + Math.random()*0.10,
          r: 2 + Math.random()*3,
          a: 0.55 + Math.random()*0.35
        });
      }
      const start = performance.now();
      function anim(t){
        const dt = (t-start)/1000;
        ctx.clearRect(0,0,w,h);
        for(const c of confetti){
          c.vy += c.g;
          c.x += c.vx;
          c.y += c.vy;
          c.a *= 0.996;
          ctx.globalAlpha = c.a;
          ctx.beginPath();
          ctx.arc(c.x,c.y,c.r,0,Math.PI*2);
          ctx.fillStyle = getComputedStyle(document.body).getPropertyValue("--fg").trim() || "#fff";
          ctx.fill();
        }
        ctx.globalAlpha = 1;
        if(dt < 1.8){
          requestAnimationFrame(anim);
        }else{
          confettiCanvas.style.display="none";
        }
      }
      requestAnimationFrame(anim);
    }

    window.addEventListener("resize", ()=>{
      confettiCanvas.width = window.innerWidth;
      confettiCanvas.height = window.innerHeight;
    });

    // =========================
    // Inline list
    // =========================
    function toggleInlineList(force){
      if(typeof force === "boolean"){
        settings.inlineListVisible = force ? 1 : 0;
      }else{
        settings.inlineListVisible = settings.inlineListVisible ? 0 : 1;
      }
      persistAll();
      renderAll();
    }

    function renderInlineTaskList(){
      inlineTaskList.innerHTML = "";
      const tasks = filteredTasks();
      if(!tasks.length){
        const p = document.createElement("p");
        p.className="help";
        p.textContent="Aucune t√¢che dans la s√©lection.";
        inlineTaskList.appendChild(p);
        return;
      }

      for(const t of tasks){
        const row = document.createElement("div");
        row.className = "item";

        const left = document.createElement("div");
        left.className = "t";

        const name = document.createElement("div");
        name.className = "name";
        name.textContent = t.title;

        const sub = document.createElement("div");
        sub.className = "sub";
        sub.textContent = `${t.cat || "INBOX"} ¬∑ ${t.ethLeft}/${t.ethStart}` + (t.pinned ? " ¬∑ √©pingl√©e" : "");

        left.appendChild(name);
        left.appendChild(sub);

        const up = document.createElement("button");
        up.className="iconBtn";
        up.textContent="‚Üë";
        up.title="Monter";
        up.onclick = ()=>moveTask(t.id, -1);

        const down = document.createElement("button");
        down.className="iconBtn";
        down.textContent="‚Üì";
        down.title="Descendre";
        down.onclick = ()=>moveTask(t.id, +1);

        row.onclick = (ev)=>{
          if(ev.target && ev.target.closest && ev.target.closest("button")) return;
          setCurrent(t.id);
        };

        row.appendChild(left);
        row.appendChild(up);
        row.appendChild(down);
        inlineTaskList.appendChild(row);
      }
    }

    // =========================
    // HUD rendering (minimal)
    // - restantes/d√©part t√¢ches
    // - √©torions restants/d√©part
    // - fait
    // - temps √©coul√© (t√¢che en cours)
    // =========================
    function renderHUD(){
      computeStartCountsIfEmpty();
      const tasksLeft = state.tasks.length;
      const tasksStart = Math.max(state.startCounts.tasks, tasksLeft + state.done.length);
      const ethLeft = state.tasks.reduce((a,t)=>a+(t.ethLeft||0),0);
      const ethStart = Math.max(state.startCounts.eth, ethLeft + state.done.reduce((a,t)=>a+(t.ethStart||0),0));
      const doneCount = state.done.length;

      // timer elapsed
      const t = state.timer;
      let elapsed = "0:00";
      if(t && t.taskId === state.currentId){
        elapsed = fmtTime(t.elapsedMs||0);
      }

      hud.innerHTML = `
        <div class="pill">${tasksLeft}/${tasksStart} t√¢ches</div>
        <div class="pill">${ethLeft}/${ethStart} √©torions</div>
        <div class="pill">${doneCount} fait</div>
        <div class="pill">${elapsed}</div>
      `;
    }

    // =========================
    // Main rendering
    // =========================
    function renderMain(){
      ensureCurrent();
      const t = currentTask();

      // title
      currentTitle.textContent = t ? t.title : "Aucune t√¢che";

      // big progress: inverse (bar full -> empties as you progress)
      computeStartCountsIfEmpty();
      const totalStartEth = Math.max(1, state.startCounts.eth || 1);
      const ethLeft = state.tasks.reduce((a,x)=>a+(x.ethLeft||0),0);
      const doneEth = totalStartEth - ethLeft;
      const pct = clamp((doneEth / totalStartEth) * 100, 0, 100);

      // bar shows "remaining fill": full at start -> empty at 100%
      const remainingPct = 100 - pct;
      taskFill.style.width = `${remainingPct}%`;
      taskPct.textContent = `${Math.round(pct)}%`;

      // eth bar for current task
      if(!t){
        ethFill.style.width = `0%`;
        ethTicks.innerHTML = "";
      }else{
        const left = t.ethLeft||0;
        const start = Math.max(1, t.ethStart||1);
        const ethPct = (left/start)*100;
        ethFill.style.width = `${ethPct}%`;

        ethTicks.innerHTML = "";
        for(let i=0;i<start;i++){
          const dot = document.createElement("div");
          dot.className = "tick " + ((i < left) ? "on" : "");
          ethTicks.appendChild(dot);
        }

        btnPin.classList.toggle("pressed", !!t.pinned);
      }
    }

    function renderAll(){
      rolloverIfNeeded();
      applyTheme();
      applyFocus();
      renderHUD();
      renderMain();

      // inline list
      inlineListWrap.style.display = settings.inlineListVisible ? "" : "none";
      if(settings.inlineListVisible) renderInlineTaskList();
    }

    // =========================
    // Drawer rendering
    // =========================
    function openDrawer(){
      drawerBack.style.display="block";
      drawer.classList.add("open");
      renderPanel();
    }
    function closeDrawer(){
      drawerBack.style.display="none";
      drawer.classList.remove("open");
    }

    function renderTabs(){
      tabsEl.innerHTML = "";
      for(const t of TAB_DEFS){
        const b = document.createElement("button");
        b.className = "tab" + (t.key===activeTab ? " active" : "");
        b.textContent = t.label;
        b.onclick = ()=>{ activeTab = t.key; renderTabs(); renderPanel(); };
        tabsEl.appendChild(b);
      }
    }

    function renderPanel(){
      drawerView.innerHTML = "";
      const view = document.createElement("div");

      if(activeTab==="inbox"){
        view.appendChild(viewInbox());
      }else if(activeTab==="liste"){
        view.appendChild(viewList());
      }else if(activeTab==="cats"){
        view.appendChild(viewCats());
      }else if(activeTab==="sets"){
        view.appendChild(viewSets());
      }else if(activeTab==="mode"){
        view.appendChild(viewMode());
      }else if(activeTab==="energie"){
        view.appendChild(viewEnergie());
      }else if(activeTab==="params"){
        view.appendChild(viewParams());
      }else if(activeTab==="profiles"){
        view.appendChild(viewProfiles());
      }else if(activeTab==="banks"){
        view.appendChild(viewBanks());
      }else if(activeTab==="kiff"){
        view.appendChild(viewKiffance());
      }else if(activeTab==="calib"){
        view.appendChild(viewCalib());
      }else if(activeTab==="hist"){
        view.appendChild(viewHist());
      }else if(activeTab==="rapport"){
        view.appendChild(viewRapport());
      }else{
        view.appendChild(section("Info","(onglet non impl√©ment√©)"));
      }

      drawerView.appendChild(view);
    }

    function section(title, inner){
      const s = document.createElement("div");
      s.className="section";
      const h = document.createElement("h3");
      h.textContent = title;
      s.appendChild(h);
      if(typeof inner === "string"){
        const p = document.createElement("div");
        p.innerHTML = inner;
        s.appendChild(p);
      }else{
        s.appendChild(inner);
      }
      return s;
    }

    // Inbox view
    function viewInbox(){
      const wrap = document.createElement("div");

      const s1 = document.createElement("div");
      s1.className="section";
      const h = document.createElement("h3");
      h.textContent = "Importer une liste";
      s1.appendChild(h);

      const ta = document.createElement("textarea");
      ta.rows = 8;
      ta.placeholder =
`CATEGORIE
T√¢che A - 3
T√¢che B 2
AUTRE CATEGORIE
T√¢che C - 1
T√¢che D ! - 4`;
      s1.appendChild(ta);

      const row = document.createElement("div");
      row.className="row";
      row.style.marginTop="10px";

      const b = document.createElement("button");
      b.className="btn";
      b.textContent="Ajouter √† la liste active";
      b.onclick = ()=>{
        const added = parseInbox(ta.value);
        if(!added.length) return;
        state.tasks.push(...added);
        // update categories selection if needed
        const cats = new Set(state.tasks.map(t=>t.cat||"INBOX"));
        if(!settings.activeCats || settings.activeCats.length===0){
          settings.activeCats = ["INBOX"];
        }else{
          // keep existing; ensure INBOX exists
          if(!settings.activeCats.includes("INBOX")) settings.activeCats.push("INBOX");
        }
        // set baseline only if empty
        if(state.startCounts.tasks===0 && state.startCounts.eth===0){
          state.startCounts = {
            tasks: state.tasks.length,
            eth: state.tasks.reduce((a,t)=>a+(t.ethStart||0),0)
          };
        }
        ensureCurrent();
        persistAll();
        renderAll();
      };

      const b2 = document.createElement("button");
      b2.className="btn ghost";
      b2.textContent="Vider le champ";
      b2.onclick = ()=>{ ta.value=""; };

      row.appendChild(b);
      row.appendChild(b2);
      s1.appendChild(row);

      const help = document.createElement("p");
      help.className="help";
      help.textContent = "Ligne en MAJUSCULES = cat√©gorie. T√¢che avec '- 3' ou ' 3' en fin = √©torions. '!' = priorit√© (optionnel).";
      s1.appendChild(help);

      wrap.appendChild(s1);
      return wrap;
    }

    // List view
    function viewList(){
      const wrap = document.createElement("div");
      const s = document.createElement("div");
      s.className="section";
      const h = document.createElement("h3");
      h.textContent="Liste (actions minimales)";
      s.appendChild(h);

      const lst = document.createElement("div");
      lst.className="list";

      if(!state.tasks.length){
        const p = document.createElement("p");
        p.className="help";
        p.textContent="Aucune t√¢che.";
        s.appendChild(p);
      }else{
        for(const t of state.tasks){
          const row = document.createElement("div");
          row.className="item";

          const left = document.createElement("div");
          left.className="t";
          const name = document.createElement("div");
          name.className="name";
          name.textContent = t.title + (t.id===state.currentId ? " (en cours)" : "");
          const sub = document.createElement("div");
          sub.className="sub";
          sub.textContent = `${t.cat||"INBOX"} ¬∑ ${t.ethLeft}/${t.ethStart}` + (t.pinned ? " ¬∑ √©pingl√©e" : "");
          left.appendChild(name); left.appendChild(sub);

          const up = document.createElement("button");
          up.className="iconBtn";
          up.textContent="‚Üë";
          up.title="Monter";
          up.onclick = ()=>moveTask(t.id, -1);

          const down = document.createElement("button");
          down.className="iconBtn";
          down.textContent="‚Üì";
          down.title="Descendre";
          down.onclick = ()=>moveTask(t.id, +1);

          const edit = document.createElement("button");
          edit.className="iconBtn";
          edit.textContent="‚úé";
          edit.title="√âditer";
          edit.onclick = ()=>{
            const nt = prompt("Nouveau titre", t.title);
            if(nt!==null) editTaskTitle(t.id, nt);
          };

          const del = document.createElement("button");
          del.className="iconBtn";
          del.textContent="‚úï";
          del.title="Supprimer";
          del.onclick = ()=>deleteTask(t.id);

          row.onclick = (ev)=>{
            if(ev.target && ev.target.closest && ev.target.closest("button")) return;
            setCurrent(t.id);
          };

          row.appendChild(left);
          row.appendChild(up);
          row.appendChild(down);
          row.appendChild(edit);
          row.appendChild(del);
          lst.appendChild(row);
        }
        s.appendChild(lst);
      }

      wrap.appendChild(s);

      // categories filter quick
      wrap.appendChild(viewCats(true));
      return wrap;
    }

    // Categories filter view
    function viewCats(embed=false){
      const cats = Array.from(new Set(state.tasks.map(t=>t.cat||"INBOX"))).sort();
      const box = document.createElement("div");
      box.className = embed ? "section" : "section";
      const h = document.createElement("h3");
      h.textContent = embed ? "Cat√©gories actives" : "Cat√©gories";
      box.appendChild(h);

      if(!cats.length){
        const p = document.createElement("p");
        p.className="help";
        p.textContent="Aucune cat√©gorie (ajoute des t√¢ches).";
        box.appendChild(p);
        return box;
      }

      // checkboxes
      for(const c of cats){
        const row = document.createElement("div");
        row.className="row";
        row.style.justifyContent="space-between";

        const label = document.createElement("div");
        label.textContent = c;

        const cb = document.createElement("input");
        cb.type="checkbox";
        cb.style.width="18px";
        cb.style.height="18px";
        cb.checked = settings.activeCats && settings.activeCats.includes(c);
        cb.onchange = ()=>{
          settings.activeCats = settings.activeCats || [];
          if(cb.checked){
            if(!settings.activeCats.includes(c)) settings.activeCats.push(c);
          }else{
            settings.activeCats = settings.activeCats.filter(x=>x!==c);
          }
          persistAll();
          renderAll();
          renderPanel();
        };

        row.appendChild(label);
        row.appendChild(cb);
        box.appendChild(row);
      }

      const row2 = document.createElement("div");
      row2.className="row";
      row2.style.marginTop="10px";

      const all = document.createElement("button");
      all.className="btn";
      all.textContent="Tout";
      all.onclick = ()=>{
        settings.activeCats = Array.from(new Set(state.tasks.map(t=>t.cat||"INBOX")));
        persistAll();
        renderAll();
        renderPanel();
      };

      const none = document.createElement("button");
      none.className="btn ghost";
      none.textContent="Aucun filtre (tout)";
      none.onclick = ()=>{
        settings.activeCats = [];
        persistAll();
        renderAll();
        renderPanel();
      };

      row2.appendChild(all);
      row2.appendChild(none);
      box.appendChild(row2);

      return box;
    }

    // Sets view (pr√©-d√©finis + g√©n√©rateurs)
    function viewSets(){
      const wrap = document.createElement("div");

      // prebuilt: Hospital tour + Consult
      const s1 = document.createElement("div");
      s1.className="section";
      s1.innerHTML = `
        <h3>Sets (pr√©-d√©finis)</h3>
        <p class="help">Objectif: t√¢ches syst√©matiques. Tu peux g√©n√©rer un set et l‚Äôajouter √† la liste active (prioritaire, dans l‚Äôordre).</p>
      `;

      const row = document.createElement("div");
      row.className="row";

      const sel = document.createElement("select");
      sel.innerHTML = `
        <option value="hospital">H√¥pital (tour de salle)</option>
        <option value="consult">Consultations</option>
      `;

      const nb = document.createElement("input");
      nb.type="number";
      nb.min="1"; nb.max="20";
      nb.value="4";
      nb.placeholder="Nb patients";

      const add = document.createElement("button");
      add.className="btn";
      add.textContent="G√©n√©rer + Prioriser";
      add.onclick = ()=>{
        const n = clamp(parseInt(nb.value,10)||4, 1, 20);
        const type = sel.value;
        const pack = [];

        if(type==="hospital"){
          for(let i=1;i<=n;i++){
            const base = `Patient ${i}`;
            pack.push(makeTask(`${base} ‚Äî voir`, "HOPITAL", 1));
            pack.push(makeTask(`${base} ‚Äî note`, "HOPITAL", 1));
            pack.push(makeTask(`${base} ‚Äî traitement`, "HOPITAL", 1));
            pack.push(makeTask(`${base} ‚Äî dossier`, "HOPITAL", 1));
          }
        }else{
          for(let i=1;i<=n;i++){
            const base = `Consult ${i}`;
            pack.push(makeTask(`${base} ‚Äî accueil`, "CONSULT", 1));
            pack.push(makeTask(`${base} ‚Äî clinique`, "CONSULT", 2));
            pack.push(makeTask(`${base} ‚Äî plan`, "CONSULT", 1));
            pack.push(makeTask(`${base} ‚Äî note`, "CONSULT", 1));
          }
        }

        // add pack at top in order + pin first
        if(pack.length){
          pack[0].pinned = true;
          state.tasks = [...pack, ...state.tasks];
          // update baseline if empty
          if(state.startCounts.tasks===0 && state.startCounts.eth===0){
            state.startCounts = {
              tasks: state.tasks.length,
              eth: state.tasks.reduce((a,t)=>a+(t.ethStart||0),0)
            };
          }
          ensureCurrent();
          persistAll();
          renderAll();
          renderPanel();
        }
      };

      row.appendChild(sel);
      row.appendChild(nb);
      row.appendChild(add);
      s1.appendChild(row);

      wrap.appendChild(s1);
      return wrap;
    }

    // Mode view (roulette settings etc.)
    function viewMode(){
      const s = document.createElement("div");
      s.className="section";
      s.innerHTML = `<h3>Mode</h3>`;

      const row1 = document.createElement("div");
      row1.className="row";

      const sel = document.createElement("select");
      sel.innerHTML = `
        <option value="random">Roulette al√©atoire</option>
        <option value="ordered">Dans l‚Äôordre</option>
      `;
      sel.value = settings.rouletteMode;
      sel.onchange = ()=>{ settings.rouletteMode = sel.value; persistAll(); };

      const strat = document.createElement("select");
      strat.innerHTML = `
        <option value="pinnedFirst">√âpingl√©es d‚Äôabord</option>
        <option value="alpha">Alphabetique</option>
        <option value="chrono">Chronologique</option>
      `;
      strat.value = settings.orderedStrategy;
      strat.onchange = ()=>{ settings.orderedStrategy = strat.value; persistAll(); };

      row1.appendChild(sel);
      row1.appendChild(strat);
      s.appendChild(row1);

      const help = document.createElement("p");
      help.className="help";
      help.textContent="Le mode 'Dans l‚Äôordre' ignore le hasard. Utile quand tu veux une ex√©cution syst√©matique.";
      s.appendChild(help);

      return s;
    }

    // Energie view (fatigue/motivation affects celebration surprise)
    function viewEnergie(){
      const s = document.createElement("div");
      s.className="section";
      s.innerHTML = `<h3>√ânergie</h3><p class="help">La c√©l√©bration reste une surprise. Ici tu r√®gles le comportement global.</p>`;

      const row1 = document.createElement("div");
      row1.className="row";

      const fat = document.createElement("select");
      fat.innerHTML = `
        <option value="0">Fatigue: tr√®s basse</option>
        <option value="1">Fatigue: basse</option>
        <option value="2">Fatigue: moyenne</option>
        <option value="3">Fatigue: haute</option>
        <option value="4">Fatigue: tr√®s haute</option>
      `;
      fat.value = String(settings.fatigue);
      fat.onchange = ()=>{ settings.fatigue = parseInt(fat.value,10); persistAll(); };

      const mot = document.createElement("select");
      mot.innerHTML = `
        <option value="0">Motivation: tr√®s basse</option>
        <option value="1">Motivation: basse</option>
        <option value="2">Motivation: moyenne</option>
        <option value="3">Motivation: haute</option>
        <option value="4">Motivation: tr√®s haute</option>
      `;
      mot.value = String(settings.motivation);
      mot.onchange = ()=>{ settings.motivation = parseInt(mot.value,10); persistAll(); };

      row1.appendChild(fat);
      row1.appendChild(mot);
      s.appendChild(row1);

      const row2 = document.createElement("div");
      row2.className="row";
      row2.style.marginTop="10px";

      const auto = document.createElement("input");
      auto.type="number";
      auto.min="4"; auto.max="20";
      auto.value = String(settings.celeAutoCloseSec||10);
      auto.placeholder="Auto-close (sec)";
      auto.onchange = ()=>{ settings.celeAutoCloseSec = clamp(parseInt(auto.value,10)||10,4,20); persistAll(); };

      const chance = document.createElement("input");
      chance.type="number";
      chance.min="0.05"; chance.max="0.60";
      chance.step="0.01";
      chance.value = String(settings.celeChanceBase||0.22);
      chance.onchange = ()=>{ settings.celeChanceBase = clamp(parseFloat(chance.value)||0.22,0.05,0.60); persistAll(); };

      row2.appendChild(auto);
      row2.appendChild(chance);
      s.appendChild(row2);

      return s;
    }

    // Params view (visual display options minimal)
    function viewParams(){
      const s = document.createElement("div");
      s.className="section";
      s.innerHTML = `<h3>Param√®tres</h3>`;

      const row = document.createElement("div");
      row.className="row";

      const theme = document.createElement("select");
      theme.innerHTML = `
        <option value="light">Th√®me clair</option>
        <option value="dark">Th√®me sombre</option>
      `;
      theme.value = settings.theme;
      theme.onchange = ()=>{ settings.theme = theme.value; applyTheme(); persistAll(); };

      const focus = document.createElement("select");
      focus.innerHTML = `
        <option value="0">Focus: non</option>
        <option value="1">Focus: oui</option>
      `;
      focus.value = String(settings.focus||0);
      focus.onchange = ()=>{ settings.focus = parseInt(focus.value,10); applyFocus(); persistAll(); renderAll(); };

      row.appendChild(theme);
      row.appendChild(focus);
      s.appendChild(row);

      const help = document.createElement("p");
      help.className="help";
      help.textContent="Le mode focus masque ce qui n‚Äôest pas n√©cessaire, mais conserve les compteurs essentiels.";
      s.appendChild(help);

      return s;
    }

    // Profiles (placeholder, keeps door open)
    function viewProfiles(){
      const s = document.createElement("div");
      s.className="section";
      s.innerHTML = `
        <h3>Profils</h3>
        <p class="help">Espace pr√©vu pour des presets complets (affichage, √©nergie, mode, filtres) sans surcharger l‚Äôinterface. (Impl√©mentation minimale ici.)</p>
      `;
      return s;
    }

    // Banks (export/import)
    function viewBanks(){
      const s = document.createElement("div");
      s.className="section";
      s.innerHTML = `<h3>Textes / Export</h3>`;

      const row = document.createElement("div");
      row.className="row";

      const exp1 = document.createElement("button");
      exp1.className="btn";
      exp1.textContent="Exporter (JSON complet)";
      exp1.onclick = ()=>{
        const payload = { settings, state, notes, habits, kiffBank, exportedAt: nowISO() };
        downloadText(`eliminator_export_${dayKey()}.json`, JSON.stringify(payload, null, 2));
      };

      const exp2 = document.createElement("button");
      exp2.className="btn";
      exp2.textContent="Exporter rapport (TXT)";
      exp2.onclick = ()=>{
        downloadText(`eliminator_rapport_${dayKey()}.txt`, buildReportText());
      };

      row.appendChild(exp1);
      row.appendChild(exp2);
      s.appendChild(row);

      const help = document.createElement("p");
      help.className="help";
      help.textContent="Export utile pour r√©cup√©rer: t√¢ches faites, t√¢ches restantes, habitudes, stats.";
      s.appendChild(help);

      return s;
    }

    // Kiffance view (4 buckets + add)
    function viewKiffance(){
      const wrap = document.createElement("div");

      // quick pick
      const s0 = document.createElement("div");
      s0.className="section";
      s0.innerHTML = `<h3>Kiffance</h3><p class="help">Banco: 4 dur√©es. Tu peux rafra√Æchir une suggestion et l‚Äôajouter √† la liste active si tu veux.</p>`;

      const row = document.createElement("div");
      row.className="row";

      const sel = document.createElement("select");
      sel.innerHTML = `
        <option value="5m">5 min</option>
        <option value="10m">10 min</option>
        <option value="15m">15 min</option>
        <option value="25m+">25 min+</option>
      `;
      const out = document.createElement("input");
      out.type="text";
      out.readOnly = true;
      out.placeholder="Suggestion‚Ä¶";

      function refresh(){
        const k = sel.value;
        const arr = (kiffBank.buckets[k] || []);
        out.value = arr.length ? arr[rand(arr.length)] : "Banque vide";
      }
      refresh();

      sel.onchange = refresh;

      const refreshBtn = document.createElement("button");
      refreshBtn.className="btn";
      refreshBtn.textContent="Rafra√Æchir";
      refreshBtn.onclick = refresh;

      const addBtn = document.createElement("button");
      addBtn.className="btn";
      addBtn.textContent="Ajouter en t√¢che";
      addBtn.onclick = ()=>{
        const k = sel.value;
        const txt = (out.value||"").trim();
        if(!txt) return;
        const eth = (k==="5m")?1:(k==="10m")?2:(k==="15m")?3:5;
        state.tasks.unshift(makeTask(txt, "KIFFANCE", eth));
        ensureCurrent();
        persistAll();
        renderAll();
      };

      row.appendChild(sel);
      row.appendChild(refreshBtn);
      s0.appendChild(row);
      s0.appendChild(out);

      const row2 = document.createElement("div");
      row2.className="row";
      row2.style.marginTop="10px";
      row2.appendChild(addBtn);
      s0.appendChild(row2);

      wrap.appendChild(s0);

      // add to bank
      const s1 = document.createElement("div");
      s1.className="section";
      s1.innerHTML = `<h3>Ajouter √† la banque</h3>`;
      const t = document.createElement("input");
      t.placeholder="Nouvelle kiffance (texte)";
      const rowA = document.createElement("div");
      rowA.className="row";
      const sel2 = document.createElement("select");
      sel2.innerHTML = sel.innerHTML;

      const add = document.createElement("button");
      add.className="btn";
      add.textContent="Ajouter";
      add.onclick = ()=>{
        const txt = (t.value||"").trim();
        if(!txt) return;
        const k = sel2.value;
        kiffBank.buckets[k] = kiffBank.buckets[k] || [];
        kiffBank.buckets[k].push(txt);
        t.value="";
        persistAll();
        renderPanel();
      };

      rowA.appendChild(sel2);
      rowA.appendChild(add);
      s1.appendChild(t);
      s1.appendChild(rowA);
      s1.appendChild(Object.assign(document.createElement("p"), {className:"help", textContent:"La banque est sauvegard√©e. Pas de c√©l√©bration ici (√ßa reste une surprise, pas une machine √† confettis)."}));
      wrap.appendChild(s1);

      return wrap;
    }

    // Calib (baseline reset)
    function viewCalib(){
      const s = document.createElement("div");
      s.className="section";
      s.innerHTML = `<h3>Calibrage</h3><p class="help">Recalibre les compteurs de d√©part (utile si tu importes beaucoup en cours de route).</p>`;

      const b = document.createElement("button");
      b.className="btn";
      b.textContent="Recalibrer d√©part (t√¢ches + √©torions)";
      b.onclick = ()=>{
        state.startCounts = {
          tasks: state.tasks.length,
          eth: state.tasks.reduce((a,t)=>a+(t.ethStart||0),0)
        };
        persistAll();
        renderAll();
      };

      s.appendChild(b);
      return s;
    }

    // Hist (daily snapshots)
    function viewHist(){
      const s = document.createElement("div");
      s.className="section";
      s.innerHTML = `<h3>Historique</h3><p class="help">Snapshots journaliers (auto). Export via ‚ÄúTextes‚Äù.</p>`;

      const lst = document.createElement("div");
      lst.className="list";

      const combined = [...state.history, buildDailySnapshot(dayKey())].slice(-30).reverse();
      for(const it of combined){
        const row = document.createElement("div");
        row.className="item";
        const left = document.createElement("div");
        left.className="t";
        const name = document.createElement("div");
        name.className="name";
        name.textContent = it.day;
        const sub = document.createElement("div");
        sub.className="sub";
        sub.textContent = `${it.totalDone} fait ¬∑ ${it.ethDone} √©torions ¬∑ reste ${it.remainingTasks} / ${it.remainingEth}`;
        left.appendChild(name); left.appendChild(sub);
        row.appendChild(left);
        lst.appendChild(row);
      }

      s.appendChild(lst);
      return s;
    }

    // Rapport (includes habits)
    function buildReportText(){
      const today = dayKey();
      const snap = buildDailySnapshot(today);

      const remaining = state.tasks.map(t=>`- ${t.title} (${t.cat||"INBOX"} ¬∑ ${t.ethLeft}/${t.ethStart})`).join("\n") || "- (aucune)";
      const doneToday = state.done
        .filter(t => (t.doneAt||"").startsWith(today))
        .map(t=>`- ${t.title} (${t.cat||"INBOX"} ¬∑ ${t.ethStart})`)
        .join("\n") || "- (aucune)";

      const hab = habits.map(h=>{
        const boxes = `${h.checked}/${h.total}`;
        return `- ${h.name} : ${boxes}`;
      }).join("\n") || "- (aucune)";

      return [
        `ELIMINATOR ‚Äî Rapport du ${today}`,
        ``,
        `Fait (aujourd‚Äôhui):`,
        doneToday,
        ``,
        `Reste (actif):`,
        remaining,
        ``,
        `Habitudes:`,
        hab,
        ``,
        `Stats:`,
        `- t√¢ches faites: ${snap.totalDone}`,
        `- √©torions faits: ${snap.ethDone}`,
        `- t√¢ches restantes: ${snap.remainingTasks}`,
        `- √©torions restants: ${snap.remainingEth}`,
        ``,
        `Notes (dernieres):`,
        (notes.slice(0,6).map(n=>`- ${new Date(n.at).toLocaleString()} : ${n.text}`).join("\n") || "- (aucune)")
      ].join("\n");
    }

    function viewRapport(){
      const s = document.createElement("div");
      s.className="section";
      s.innerHTML = `<h3>Rapport</h3><p class="help">Rapport texte exportable. Inclut habitudes + fait + reste.</p>`;

      const pre = document.createElement("textarea");
      pre.rows = 16;
      pre.value = buildReportText();

      const row = document.createElement("div");
      row.className="row";
      row.style.marginTop="10px";

      const b = document.createElement("button");
      b.className="btn";
      b.textContent="Exporter en TXT";
      b.onclick = ()=>downloadText(`eliminator_rapport_${dayKey()}.txt`, buildReportText());

      row.appendChild(b);

      s.appendChild(pre);
      s.appendChild(row);
      return s;
    }

    // =========================
    // Habit tracker tab lives in "rapport" and "hist" snapshots already.
    // We'll add it under "energie" or "params"? Better: under "rapport" but user asked an onglet.
    // We'll embed it in "profiles" via quick, AND also include in "rapport".
    // Minimal: put it in "params" view? Non: they asked separate.
    // We'll add an additional section inside "profiles" view to keep tabs list unchanged (no new tab).
    // =========================
    function habitsSection(){
      const s = document.createElement("div");
      s.className="section";
      s.innerHTML = `<h3>Suivi des habitudes</h3><p class="help">Chaque habitude est sur une ligne: cases + reset + supprimer. Pas de c√©l√©bration ici.</p>`;

      // add form
      const row = document.createElement("div");
      row.className="row";

      const name = document.createElement("input");
      name.placeholder="Nom d‚Äôhabitude";

      const total = document.createElement("input");
      total.type="number";
      total.min="1"; total.max="30";
      total.value="10";

      const add = document.createElement("button");
      add.className="btn";
      add.textContent="Ajouter";
      add.onclick = ()=>{
        addHabit(name.value, total.value);
        name.value="";
      };

      row.appendChild(name);
      row.appendChild(total);
      row.appendChild(add);
      s.appendChild(row);

      // list
      const lst = document.createElement("div");
      lst.className="list";
      lst.style.marginTop="10px";

      if(!habits.length){
        const p = document.createElement("p");
        p.className="help";
        p.textContent="Aucune habitude.";
        lst.appendChild(p);
      }else{
        for(const h of habits){
          const rowH = document.createElement("div");
          rowH.className="item";

          const left = document.createElement("div");
          left.className="t";
          const nm = document.createElement("div");
          nm.className="name";
          nm.textContent = h.name;
          left.appendChild(nm);

          // boxes
          const boxes = document.createElement("div");
          boxes.style.display="flex";
          boxes.style.gap="6px";
          boxes.style.flexWrap="nowrap";
          boxes.style.alignItems="center";

          for(let i=0;i<h.total;i++){
            const b = document.createElement("div");
            b.className = "tick " + (i < (h.checked||0) ? "on" : "");
            b.style.width="14px";
            b.style.height="8px";
            b.style.cursor="pointer";
            b.onclick = ()=>habitToggle(h.id, i);
            boxes.appendChild(b);
          }

          const reset = document.createElement("button");
          reset.className="iconBtn";
          reset.textContent="‚Ü∫";
          reset.title="Reset";
          reset.onclick = ()=>habitReset(h.id);

          const del = document.createElement("button");
          del.className="iconBtn";
          del.textContent="‚úï";
          del.title="Supprimer";
          del.onclick = ()=>habitDelete(h.id);

          rowH.appendChild(left);
          rowH.appendChild(boxes);
          rowH.appendChild(reset);
          rowH.appendChild(del);

          lst.appendChild(rowH);
        }
      }

      s.appendChild(lst);
      return s;
    }

    // Patch profiles view to include habits section
    const _viewProfiles = viewProfiles;
    function viewProfiles(){
      const wrap = document.createElement("div");
      wrap.appendChild(_viewProfiles());
      wrap.appendChild(habitsSection());
      return wrap;
    }

    // =========================
    // Wire events
    // =========================
    btnMenu.onclick = openDrawer;
    btnCloseDrawer.onclick = closeDrawer;
    drawerBack.onclick = closeDrawer;

    btnTheme.onclick = ()=>{
      settings.theme = (settings.theme==="light") ? "dark" : "light";
      persistAll();
      renderAll();
      renderPanel();
    };

    btnFocus.onclick = ()=>{
      settings.focus = settings.focus ? 0 : 1;
      persistAll();
      renderAll();
    };

    btnInlineList.onclick = ()=>toggleInlineList();
    btnInlineListHide.onclick = ()=>toggleInlineList(false);

    btnReset.onclick = ()=>{
      // reset tasks only (notes/habits stay)
      state.tasks = [];
      state.done = [];
      state.currentId = null;
      state.startCounts = { tasks:0, eth:0 };
      state.timer = { taskId:null, elapsedMs:0, running:false, startedAt:0 };
      state.streak = { completedSinceCele: 0 };
      persistAll();
      renderAll();
      renderPanel();
    };

    btnRoulette.onclick = ()=>{
      const picked = pickRoulette();
      if(!picked) return;
      btnRoulette.classList.remove("spin");
      void btnRoulette.offsetWidth;
      btnRoulette.classList.add("spin");
      setCurrent(picked.id);
    };

    btnDegomme.onclick = degommeOneEth;

    btnNotes.onclick = openNotes;
    btnCloseNotes.onclick = closeNotes;
    notesBack.onclick = closeNotes;

    btnAddNote.onclick = addNote;
    btnClearNotes.onclick = ()=>{
      if(confirm("Vider toutes les notes ?")){
        notes = [];
        persistAll();
        renderNotes();
      }
    };

    btnPin.onclick = pinToggle;
    btnDown.onclick = pushDownCurrent;
    btnDel.onclick = ()=>{ const t=currentTask(); if(t) deleteTask(t.id); };
    btnDone.onclick = ()=>{ const t=currentTask(); if(t) markDone(t.id); };

    btnEdit.onclick = ()=>{
      const t = currentTask();
      if(!t) return;
      const nt = prompt("Nouveau titre", t.title);
      if(nt!==null) editTaskTitle(t.id, nt);
    };

    btnCloseCele.onclick = closeCelebration;
    celeBack.onclick = closeCelebration;

    // =========================
    // Timer loop
    // =========================
    setInterval(()=>{
      tickTimer();
      // only update HUD/timer frequently (cheap)
      renderHUD();
      persistAll();
    }, 1000);

    // =========================
    // Boot
    // =========================
    function boot(){
      // migrate theme value
      if(settings.theme!=="light" && settings.theme!=="dark") settings.theme="light";

      // default active cats
      if(!settings.activeCats || !Array.isArray(settings.activeCats)) settings.activeCats=["INBOX"];

      renderTabs();
      renderAll();
      renderPanel();
    }

    boot();
  </script>
</body>
</html>
