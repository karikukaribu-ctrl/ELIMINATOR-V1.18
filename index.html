<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>ELIMINATOR</title>

  <style>
    :root{
      /* Light (par d√©faut) ‚Äî √©l√©gant, vitr√©, sobre */
      --bg: #f6f8fc;
      --fg: #0f172a;
      --muted: rgba(15,23,42,.60);
      --muted2: rgba(15,23,42,.42);
      --glass: rgba(255,255,255,.60);
      --glass2: rgba(255,255,255,.46);
      --stroke: rgba(15,23,42,.10);
      --shadow: 0 18px 50px rgba(15,23,42,.12);
      --shadow2: 0 10px 26px rgba(15,23,42,.10);
      --accent: rgba(70, 140, 255, .95);
      --accent2: rgba(40, 200, 160, .85);

      --radius: 18px;
      --radius2: 26px;

      --topbarH: 64px;

      --titleSize: 48px;
      --subtitleSize: 14px;

      --progressH: 34px; /* grande barre */
      --ethH: 14px;      /* mini barre */

      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    /* Dark */
    [data-theme="dark"]{
      --bg:#0b1020;
      --fg:#eaf0ff;
      --muted: rgba(234,240,255,.64);
      --muted2: rgba(234,240,255,.40);
      --glass: rgba(255,255,255,.07);
      --glass2: rgba(255,255,255,.05);
      --stroke: rgba(255,255,255,.11);
      --shadow: 0 22px 60px rgba(0,0,0,.45);
      --shadow2: 0 12px 30px rgba(0,0,0,.35);
      --accent: rgba(120, 170, 255, .95);
      --accent2: rgba(124,255,199,.78);
    }

    html, body{
      height:100%;
      margin:0;
      background: radial-gradient(1200px 700px at 50% -10%, rgba(70,140,255,.18), transparent 60%),
                  radial-gradient(900px 520px at 90% 0%, rgba(40,200,160,.14), transparent 62%),
                  var(--bg);
      color:var(--fg);
      font-family:var(--font);
      overflow-x:hidden;
    }

    /* Top bar: tout ce qui est actionnable / HUD au-dessus */
    .topbar{
      position:fixed;
      top:0; left:0; right:0;
      height:var(--topbarH);
      display:flex;
      align-items:center;
      gap:12px;
      padding: 10px 12px;
      z-index: 40;
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      background: linear-gradient(to bottom, var(--glass), rgba(255,255,255,0));
      border-bottom:1px solid var(--stroke);
    }

    .topbar .left, .topbar .right{
      display:flex; align-items:center; gap:10px;
      min-width: 0;
    }
    .topbar .left{ flex:1; }
    .topbar .right{ flex:1; justify-content:flex-end; }

    .btn{
      appearance:none;
      border:1px solid var(--stroke);
      background: var(--glass2);
      color:var(--fg);
      border-radius: 999px;
      padding: 10px 12px;
      font-size: 13px;
      line-height: 1;
      display:inline-flex;
      align-items:center;
      gap:8px;
      cursor:pointer;
      box-shadow: var(--shadow2);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      user-select:none;
    }
    .btn:hover{ transform: translateY(-1px); }
    .btn:active{ transform: translateY(0px); }
    .btn.primary{
      border-color: rgba(70,140,255,.35);
      background: linear-gradient(180deg, rgba(70,140,255,.18), rgba(255,255,255,0));
    }
    .btn.danger{
      border-color: rgba(255,90,90,.30);
      background: linear-gradient(180deg, rgba(255,90,90,.12), rgba(255,255,255,0));
    }
    .btn.ghost{
      background: transparent;
      border-color: transparent;
      box-shadow: none;
    }

    .chip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: var(--glass2);
      box-shadow: var(--shadow2);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
    }
    .chip b{ color: var(--fg); font-weight: 700; }

    .toggle{
      display:inline-flex;
      gap:6px;
      border:1px solid var(--stroke);
      background: var(--glass2);
      padding: 5px;
      border-radius: 999px;
      box-shadow: var(--shadow2);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    }
    .toggle button{
      border:0;
      background: transparent;
      color: var(--muted);
      padding: 7px 10px;
      border-radius: 999px;
      cursor:pointer;
      font-size: 12px;
    }
    .toggle button.active{
      background: linear-gradient(180deg, rgba(70,140,255,.22), rgba(255,255,255,0));
      color: var(--fg);
      border: 1px solid rgba(70,140,255,.25);
    }

    /* Main layout: top controls remain above, main content centered vertically but under topbar */
    .main{
      min-height: 100vh;
      padding-top: calc(var(--topbarH) + 18px);
      padding-bottom: 24px;
      display:flex;
      justify-content:center;
    }

    .stage{
      width: min(920px, calc(100vw - 22px));
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: 16px;
    }

    /* Keep a big clean central zone */
    .hero{
      width: 100%;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: 6px;
      margin-top: 14px;
    }
    .title{
      font-size: var(--titleSize);
      letter-spacing: -0.02em;
      font-weight: 860;
      margin:0;
      line-height: 1.02;
      text-align:center;
    }
    .subtitle{
      margin:0;
      font-size: var(--subtitleSize);
      color: var(--muted);
      text-align:center;
    }

    /* Progress area: minimal framing (no boxes everywhere) */
    .progressWrap{
      width:100%;
      margin-top: 8px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: 10px;
    }

    .progressBar{
      width: 100%;
      height: var(--progressH);
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.15);
      overflow:hidden;
      position:relative;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      box-shadow: var(--shadow);
    }
    [data-theme="dark"] .progressBar{
      background: rgba(255,255,255,.05);
    }
    .progressFill{
      height:100%;
      width:0%;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(70,140,255,.85), rgba(40,200,160,.72));
      transition: width .30s ease;
    }
    .progressText{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight: 750;
      font-size: 13px;
      color: rgba(255,255,255,.92);
      text-shadow: 0 2px 10px rgba(0,0,0,.30);
      mix-blend-mode: normal;
      pointer-events:none;
    }

    .targetTitle{
      width: 100%;
      text-align:center;
      font-size: 20px;
      font-weight: 780;
      letter-spacing: -0.01em;
      margin-top: 4px;
      padding: 0 4px;
    }
    .targetMeta{
      width:100%;
      display:flex;
      justify-content:center;
      gap: 14px;
      color: var(--muted);
      font-size: 12px;
      flex-wrap: wrap;
    }

    /* Eth fragments bar (dotted segments) */
    .ethBar{
      width: 100%;
      height: var(--ethH);
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.10);
      overflow:hidden;
      position:relative;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      box-shadow: var(--shadow2);
    }
    [data-theme="dark"] .ethBar{
      background: rgba(255,255,255,.04);
    }
    .ethFill{
      height:100%;
      width:0%;
      border-radius: 999px;
      background: rgba(70,140,255,.40);
      transition: width .20s ease;
    }
    .ethDots{
      position:absolute;
      inset:0;
      background-image: radial-gradient(circle at 1px 50%, rgba(255,255,255,.55) 1px, transparent 1.5px);
      background-size: 10px 100%;
      opacity: .18;
      pointer-events:none;
    }

    .actions{
      width:100%;
      display:flex;
      justify-content:center;
      gap: 12px;
      flex-wrap: wrap;
      margin-top: 10px;
    }

    .rouletteBtn{
      padding: 14px 18px;
      font-size: 14px;
      font-weight: 760;
      border-radius: 999px;
      border: 1px solid rgba(70,140,255,.30);
      background: linear-gradient(180deg, rgba(70,140,255,.15), rgba(255,255,255,0));
      box-shadow: var(--shadow);
      min-width: 160px;
      display:inline-flex;
      justify-content:center;
      gap: 10px;
    }
    .rouletteWheel{
      width: 18px; height: 18px;
      border-radius: 50%;
      border: 2px solid var(--fg);
      opacity: .85;
      position: relative;
    }
    .rouletteWheel:after{
      content:"";
      position:absolute;
      width: 2px; height: 8px;
      background: var(--fg);
      left: 50%;
      top: 1px;
      transform: translateX(-50%);
      opacity: .85;
    }
    .spin{
      animation: spin .65s ease-in-out;
    }
    @keyframes spin{ from{ transform: rotate(0deg);} to{ transform: rotate(720deg);} }

    .smashBtn{
      padding: 14px 18px;
      font-size: 14px;
      font-weight: 780;
      border-radius: 999px;
      border: 1px solid rgba(40,200,160,.28);
      background: linear-gradient(180deg, rgba(40,200,160,.14), rgba(255,255,255,0));
      box-shadow: var(--shadow);
      min-width: 220px;
      justify-content:center;
    }

    /* bottom mini actions (menu + notes) near smash as user asked before */
    .miniRow{
      width:100%;
      display:flex;
      justify-content:center;
      gap: 10px;
      margin-top: 6px;
    }

    /* Drawer (menu lat√©ral) */
    .drawerOverlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index: 60;
      display:none;
    }
    .drawer{
      position:fixed;
      top:0;
      bottom:0;
      left:0;
      width: min(420px, 92vw);
      background: var(--glass);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border-right: 1px solid var(--stroke);
      box-shadow: var(--shadow);
      z-index: 61;
      transform: translateX(-110%);
      transition: transform .24s ease;
      display:flex;
      flex-direction:column;
    }
    .drawer.open{ transform: translateX(0); }
    .drawerOverlay.open{ display:block; }

    .drawerHead{
      height: var(--topbarH);
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 10px 12px;
      border-bottom: 1px solid var(--stroke);
    }
    .drawerHead .h{
      font-weight: 820;
      letter-spacing:-0.01em;
    }
    .tabs{
      display:flex;
      gap: 6px;
      padding: 10px 10px 0 10px;
      flex-wrap: wrap;
    }
    .tab{
      border:1px solid var(--stroke);
      background: var(--glass2);
      color: var(--muted);
      border-radius: 999px;
      padding: 8px 10px;
      font-size: 12px;
      cursor:pointer;
      user-select:none;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
    }
    .tab.active{
      color: var(--fg);
      border-color: rgba(70,140,255,.25);
      background: linear-gradient(180deg, rgba(70,140,255,.18), rgba(255,255,255,0));
    }
    .panel{
      padding: 12px 12px 16px 12px;
      overflow:auto;
      flex:1;
    }

    /* Cards inside menu (keep minimal) */
    .card{
      border: 1px solid var(--stroke);
      background: var(--glass2);
      border-radius: var(--radius);
      padding: 12px;
      box-shadow: var(--shadow2);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      margin-bottom: 10px;
    }
    .card h3{
      margin:0 0 8px 0;
      font-size: 14px;
      letter-spacing:-0.01em;
    }
    .help{
      margin:0;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.35;
    }

    textarea, input, select{
      width:100%;
      border-radius: 14px;
      border:1px solid var(--stroke);
      padding: 10px 10px;
      background: rgba(255,255,255,.25);
      color: var(--fg);
      outline:none;
      font-size: 13px;
      font-family: var(--font);
      box-sizing: border-box;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    [data-theme="dark"] textarea,
    [data-theme="dark"] input,
    [data-theme="dark"] select{
      background: rgba(255,255,255,.07);
    }
    textarea{ min-height: 140px; resize: vertical; font-family: var(--mono); }

    .row{
      display:flex;
      gap: 10px;
      align-items:center;
    }
    .row > *{ flex:1; }

    .list{
      display:flex;
      flex-direction:column;
      gap: 6px;
      margin-top: 8px;
    }
    .item{
      display:flex;
      align-items:center;
      gap: 10px;
      padding: 10px 10px;
      border-radius: 14px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.22);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    [data-theme="dark"] .item{ background: rgba(255,255,255,.06); }
    .item .t{
      flex:1;
      min-width:0;
    }
    .item .t .name{
      font-size: 13px;
      font-weight: 720;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .item .t .sub{
      font-size: 11px;
      color: var(--muted);
      margin-top: 2px;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }

    .iconBtn{
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.18);
      color: var(--fg);
      width: 34px;
      height: 34px;
      border-radius: 999px;
      display:grid;
      place-items:center;
      cursor:pointer;
      box-shadow: none;
      user-select:none;
      font-size: 13px;
    }
    [data-theme="dark"] .iconBtn{ background: rgba(255,255,255,.06); }

    /* Focus mode: hide everything except essentials but keep HUD */
    .focus .drawerOverlay,
    .focus .drawer{
      display:none !important;
    }
    .focus .miniRow{ display:none; } /* optional; you said keep HUD; menu can remain top */
    .focus .topbar .left .btn.menuBtn{ display:none; } /* keep top minimal */
    .focus .topbar .right .btn.resetBtn{ display:none; } /* you can comment this if you want */
    .focus .subtitle{ display:none; }

    /* Notes modal */
    .modalOverlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.35);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      z-index: 80;
      display:none;
    }
    .modal{
      position:fixed;
      left:50%;
      top:50%;
      transform: translate(-50%, -50%);
      width: min(680px, 92vw);
      max-height: 82vh;
      overflow:auto;
      background: var(--glass);
      border: 1px solid var(--stroke);
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      padding: 14px;
      z-index: 81;
      display:none;
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
    }
    .modalHead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      margin-bottom: 10px;
    }
    .modalHead .mh{
      font-weight: 840;
      letter-spacing:-0.01em;
    }

    /* Celebration overlay */
    .celebrateOverlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.35);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      z-index: 90;
      display:none;
      align-items:center;
      justify-content:center;
      padding: 16px;
    }
    .celebrateBox{
      width: min(720px, 92vw);
      border-radius: var(--radius2);
      border: 1px solid var(--stroke);
      background: var(--glass);
      box-shadow: var(--shadow);
      padding: 18px 16px;
      text-align:center;
      backdrop-filter: blur(18px);
      -webkit-backdrop-filter: blur(18px);
    }
    .celebrateBox .big{
      font-size: 18px;
      font-weight: 880;
      letter-spacing:-0.01em;
      margin:0 0 8px 0;
    }
    .celebrateBox .small{
      margin:0;
      font-size: 13px;
      color: var(--muted);
      line-height: 1.4;
    }

    /* Confetti canvas */
    #confetti{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index: 89;
      display:none;
    }

    /* Calendar */
    .calGrid{
      display:grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 6px;
      margin-top: 10px;
    }
    .calCell{
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.18);
      border-radius: 14px;
      padding: 8px;
      min-height: 52px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display:flex;
      flex-direction:column;
      gap: 4px;
    }
    [data-theme="dark"] .calCell{ background: rgba(255,255,255,.05); }
    .calCell .d{
      font-size: 11px;
      color: var(--muted);
    }
    .calCell .k{
      font-size: 12px;
      font-weight: 800;
    }

    /* responsive */
    @media (max-width: 520px){
      :root{
        --titleSize: 36px;
        --progressH: 30px;
      }
      .rouletteBtn{ min-width: 150px; }
      .smashBtn{ min-width: 200px; }
      .topbar{ padding: 10px 10px; }
      .chip{ display:none; } /* keep top clean on small screens */
    }
  </style>
</head>

<body data-theme="light">
  <!-- TOP BAR -->
  <div class="topbar">
    <div class="left">
      <button class="btn menuBtn" id="btnMenu">Menu</button>

      <div class="toggle" title="Th√®me">
        <button id="btnLight" class="active">Clair</button>
        <button id="btnDark">Sombre</button>
      </div>

      <button class="btn" id="btnFocus">Focus</button>
      <button class="btn resetBtn danger" id="btnReset">Reset</button>
    </div>

    <div class="right">
      <div class="chip" id="hudTasks"></div>
      <div class="chip" id="hudEth"></div>
      <div class="chip" id="hudDone"></div>
      <div class="chip" id="hudTimer"></div>
    </div>
  </div>

  <!-- DRAWER -->
  <div class="drawerOverlay" id="drawerOverlay"></div>
  <aside class="drawer" id="drawer">
    <div class="drawerHead">
      <div class="h">ELIMINATOR</div>
      <button class="btn ghost" id="btnCloseDrawer">Fermer</button>
    </div>

    <div class="tabs" id="tabs"></div>
    <div class="panel" id="panel"></div>
  </aside>

  <!-- NOTES MODAL -->
  <div class="modalOverlay" id="notesOverlay"></div>
  <div class="modal" id="notesModal">
    <div class="modalHead">
      <div class="mh">Notes</div>
      <div class="row" style="flex:0; gap:8px;">
        <button class="btn" id="btnExportNotes">Exporter</button>
        <button class="btn danger" id="btnCloseNotes">Fermer</button>
      </div>
    </div>

    <div class="card">
      <h3>Ajouter une note</h3>
      <textarea id="noteInput" placeholder="√âcris ici. (Conserv√© m√™me si tu reset les t√¢ches.)"></textarea>
      <div class="row" style="margin-top:10px;">
        <button class="btn primary" id="btnAddNote">Ajouter</button>
        <button class="btn" id="btnClearNoteInput">Effacer</button>
      </div>
      <p class="help" style="margin-top:10px;">
        Les notes sont dat√©es automatiquement et restent en m√©moire.
      </p>
    </div>

    <div class="card">
      <h3>Historique des notes</h3>
      <div class="list" id="notesList"></div>
    </div>
  </div>

  <!-- CELEBRATION -->
  <canvas id="confetti"></canvas>
  <div class="celebrateOverlay" id="celebrateOverlay">
    <div class="celebrateBox" id="celebrateBox">
      <p class="big" id="celebrateBig">Victoire</p>
      <p class="small" id="celebrateSmall">‚Ä¶</p>
    </div>
  </div>

  <!-- MAIN -->
  <div class="main">
    <div class="stage">

      <div class="hero">
        <h1 class="title">ELIMINATOR</h1>
        <p class="subtitle">D√©gomme toutes les t√¢ches. D√©gomme tous les √©thorions en cours.</p>
      </div>

      <div class="progressWrap">
        <div class="progressBar" aria-label="Progression t√¢ches">
          <div class="progressFill" id="taskFill"></div>
          <div class="progressText" id="taskPct">‚Äî</div>
        </div>

        <div style="height:10px;"></div>

        <div class="targetTitle" id="currentTitle">Aucune t√¢che</div>
        <div class="targetMeta" id="currentMeta"></div>

        <div class="ethBar" aria-label="√âthorions">
          <div class="ethFill" id="ethFill"></div>
          <div class="ethDots"></div>
        </div>

        <div class="actions">
          <button class="btn rouletteBtn" id="btnRoulette">
            <span class="rouletteWheel" id="wheel"></span>
            <span>Roulette</span>
          </button>

          <button class="btn smashBtn" id="btnSmash">üß® D√©gommer 1 √©thorion</button>
        </div>

        <div class="miniRow">
          <button class="btn" id="btnNotes">Notes</button>
          <button class="btn" id="btnQuickMenu">Menu</button>
        </div>
      </div>

    </div>
  </div>

<script>
/* ============================================================
   ELIMINATOR ‚Äî Single file, tout inclus
   - Th√®me clair par d√©faut + toggle rapide en topbar
   - Menu lat√©ral masquable + onglets
   - Interface principale √©pur√©e + centr√©e (sous topbar)
   - Progression (barre tasks + barre √©thorions)
   - Roulette (gros bouton + animation)
   - Smash (üß®) + confettis toujours en fin de t√¢che
   - C√©l√©bration popup surprise (pilot√©e fatigue/motivation)
   - Inbox import: cat√©gorie = ligne en MAJUSCULES
     t√¢ches sous la cat√©gorie; option "- N" pour √©thorions
   - Liste: √©diter / monter / descendre / supprimer / marquer "d√©j√† d√©gomm√©"
   - Kiffance (banque) 4 cat√©gories: 5, 10, 15, 25+ minutes + refresh
   - Habitudes: lignes + cases (10) + reset/suppr + report
   - Notes: modal central, persistantes (m√™me si reset t√¢ches)
   - Sets: pr√©d√©finis H√¥pital / Consultation + N patients, ordre strict, priorit√©
   - Historique + Rapport + export (JSON)
============================================================ */

/* =========================
   Storage keys + Defaults
   ========================= */
const K = {
  state: "ELIMINATOR_STATE_V5",
  settings: "ELIMINATOR_SETTINGS_V5",
  notes: "ELIMINATOR_NOTES_V5",
  history: "ELIMINATOR_HISTORY_V5",
  habits: "ELIMINATOR_HABITS_V5",
  kiff: "ELIMINATOR_KIFFANCE_V5",
  sets: "ELIMINATOR_SETS_V5"
};

const DEFAULTS = {
  theme: "light",        // light default
  focus: 0,
  ethMinutesPer: 5,
  sortMode: "roulette",  // roulette | order
  activeCats: null,      // null => toutes

  // C√©l√©brations (surprise)
  celebrationMode: "surprise",   // off | surprise | frequent
  motivation: "normal",          // low | normal | high
  fatigue: "medium",             // low | medium | high
  celebrationMinGapTasks: 2,
  celebrationMaxGapTasks: 3,
  celebrationAutoHideMs: 9000,
  celebrationChanceMin: 0.10,
  celebrationChanceMax: 0.55
};

const DEFAULT_SETS = [
  {
    id:"set_hosp",
    name:"H√¥pital ‚Äî tour de salle",
    type:"hospital",
    steps:[
      { label:"Voir patient", eth:1 },
      { label:"Note", eth:1 },
      { label:"Traitement", eth:1 },
      { label:"Dossier (encoder/r√©viser)", eth:2 }
    ]
  },
  {
    id:"set_cons",
    name:"Consultation ‚Äî flow",
    type:"consult",
    steps:[
      { label:"Accueil / objectif", eth:1 },
      { label:"Anamn√®se cibl√©e", eth:2 },
      { label:"Plan / traitement", eth:2 },
      { label:"Note / dossier", eth:2 }
    ]
  }
];

const DEFAULT_KIFF = {
  "5": [
    "Boire un verre d‚Äôeau. Respiration lente 60 secondes.",
    "Ranger une surface (30 secondes chrono).",
    "√âcrire 1 phrase: ce que je fais maintenant."
  ],
  "10": [
    "Marche 5 minutes. Retour. Hydratation.",
    "Micro-√©tirement nuque/√©paules (sans violence).",
    "Nettoyer le bureau (version minimaliste)."
  ],
  "15": [
    "Pause active: marche + lumi√®re + eau.",
    "Mini-reset mental: 3 priorit√©s, 1 action.",
    "Organisation √©clair: ouvrir le doc, pr√©parer la page."
  ],
  "25": [
    "Pause longue: bouger, respirer, manger un truc simple.",
    "R√©cup√©ration: musique + marche + eau.",
    "Reset posture + planning rapide (sans perfectionnisme)."
  ]
};

/* =========================
   State model
   ========================= */
let settings = loadJSON(K.settings, null) || {...DEFAULTS};
settings = {...DEFAULTS, ...settings};

let state = loadJSON(K.state, null);
if(!state){
  state = {
    tasks: [],
    done: [],
    currentId: null,
    startCounts: { tasks: 0, eth: 0 },
    timer: { taskId: null, elapsedMs: 0, running: false, startedAt: null },
    streak: { tasksSincePopup: 0, tasksSinceStart: 0 },
    activeSet: null, // { setId, setName, queueTaskIds, startedAt }
    dayStartISO: todayISO()
  };
}
state.timer = state.timer || { taskId:null, elapsedMs:0, running:false, startedAt:null };
state.streak = state.streak || { tasksSincePopup:0, tasksSinceStart:0 };
state.activeSet = state.activeSet || null;
state.startCounts = state.startCounts || { tasks:0, eth:0 };
state.done = state.done || [];
state.tasks = state.tasks || [];
state.dayStartISO = state.dayStartISO || todayISO();

let notes = loadJSON(K.notes, []) || [];
let history = loadJSON(K.history, []) || [];
let habits = loadJSON(K.habits, []) || []; // {id,name,boxes:[bool*10], dayISO}
let kiffBank = loadJSON(K.kiff, null) || structuredClone(DEFAULT_KIFF);
let sets = loadJSON(K.sets, null) || structuredClone(DEFAULT_SETS);

persistAll();

/* =========================
   DOM refs
   ========================= */
const el = (id)=>document.getElementById(id);

const drawer = el("drawer");
const drawerOverlay = el("drawerOverlay");
const btnMenu = el("btnMenu");
const btnQuickMenu = el("btnQuickMenu");
const btnCloseDrawer = el("btnCloseDrawer");

const tabsEl = el("tabs");
const panelEl = el("panel");

const btnLight = el("btnLight");
const btnDark = el("btnDark");
const btnFocus = el("btnFocus");
const btnReset = el("btnReset");

const hudTasks = el("hudTasks");
const hudEth = el("hudEth");
const hudDone = el("hudDone");
const hudTimer = el("hudTimer");

const taskFill = el("taskFill");
const taskPct = el("taskPct");
const currentTitle = el("currentTitle");
const currentMeta = el("currentMeta");
const ethFill = el("ethFill");

const btnRoulette = el("btnRoulette");
const wheel = el("wheel");
const btnSmash = el("btnSmash");

const btnNotes = el("btnNotes");
const notesOverlay = el("notesOverlay");
const notesModal = el("notesModal");
const btnCloseNotes = el("btnCloseNotes");
const btnAddNote = el("btnAddNote");
const btnClearNoteInput = el("btnClearNoteInput");
const btnExportNotes = el("btnExportNotes");
const noteInput = el("noteInput");
const notesList = el("notesList");

const celebrateOverlay = el("celebrateOverlay");
const celebrateBig = el("celebrateBig");
const celebrateSmall = el("celebrateSmall");
const confettiCanvas = el("confetti");
const confettiCtx = confettiCanvas.getContext("2d");

let celebrateTimer = null;
let tickTimer = null;

/* =========================
   Drawer Tabs
   ========================= */
const TAB_DEFS = [
  { key:"inbox",   label:"Inbox" },
  { key:"liste",   label:"Liste" },
  { key:"sets",    label:"Sets" },
  { key:"kiff",    label:"Kiffance" },
  { key:"habits",  label:"Habitudes" },
  { key:"hist",    label:"Hist" },
  { key:"rapport", label:"Rapport" },
  { key:"params",  label:"Param" }
];

let activeTab = "inbox";

/* =========================
   Utilities
   ========================= */
function nowISO(){ return new Date().toISOString(); }
function todayISO(){
  const d = new Date();
  const y = d.getFullYear();
  const m = String(d.getMonth()+1).padStart(2,"0");
  const da = String(d.getDate()).padStart(2,"0");
  return `${y}-${m}-${da}`;
}
function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }
function uid(){
  return Math.random().toString(16).slice(2) + Math.random().toString(16).slice(2);
}
function saveJSON(k,v){ localStorage.setItem(k, JSON.stringify(v)); }
function loadJSON(k, fallback){
  try{
    const raw = localStorage.getItem(k);
    if(!raw) return fallback;
    return JSON.parse(raw);
  }catch(e){ return fallback; }
}
function persistAll(){
  saveJSON(K.settings, settings);
  saveJSON(K.state, state);
  saveJSON(K.notes, notes);
  saveJSON(K.history, history);
  saveJSON(K.habits, habits);
  saveJSON(K.kiff, kiffBank);
  saveJSON(K.sets, sets);
}
function minutesFromEth(eth){ return (eth||0) * (settings.ethMinutesPer || 5); }
function fmtMin(min){
  min = Math.round(min);
  if(min < 60) return `${min} min`;
  const h = Math.floor(min/60);
  const m = min%60;
  return `${h}h${String(m).padStart(2,"0")}`;
}
function fmtTime(ms){
  const s = Math.floor(ms/1000);
  const mm = Math.floor(s/60);
  const ss = s%60;
  return `${String(mm).padStart(2,"0")}:${String(ss).padStart(2,"0")}`;
}
function isAllCaps(line){
  const t = (line||"").trim();
  if(!t) return false;
  const hasLetter = /[A-Z√Ä-√ñ√ò-√ù]/.test(t);
  const hasLower = /[a-z√†-√∂√∏-√ø]/.test(t);
  return hasLetter && !hasLower && t.length>=3;
}
function parseTaskLine(line){
  // "T√¢che - 3" => ethStart=3
  // Also accept: "T√¢che 3" at end (space number)
  let t = line.trim();
  if(!t) return null;

  let eth = null;
  // match "- N"
  let m = t.match(/\s*-\s*(\d+)\s*$/);
  if(m){
    eth = parseInt(m[1],10);
    t = t.replace(/\s*-\s*\d+\s*$/,"").trim();
  }else{
    // match " ... N" at end
    m = t.match(/\s+(\d+)\s*$/);
    if(m){
      eth = parseInt(m[1],10);
      // only treat as eth if preceding char isn't part of an ID like "A1"
      t = t.replace(/\s+\d+\s*$/,"").trim();
    }
  }

  eth = clamp((Number.isFinite(eth)?eth:1), 1, 999);
  return { title: t, eth };
}
function uniq(arr){
  return [...new Set(arr)];
}
function safeText(s){
  return (s||"").replace(/[<>]/g, "");
}

/* =========================
   Theme + Focus
   ========================= */
function applyTheme(){
  document.body.setAttribute("data-theme", settings.theme);
  btnLight.classList.toggle("active", settings.theme==="light");
  btnDark.classList.toggle("active", settings.theme==="dark");
}
btnLight.onclick = () => { settings.theme="light"; persistAll(); applyTheme(); renderAll(); };
btnDark.onclick = () => { settings.theme="dark"; persistAll(); applyTheme(); renderAll(); };

function applyFocus(){
  document.body.classList.toggle("focus", !!settings.focus);
  btnFocus.textContent = settings.focus ? "Quitter focus" : "Focus";
}
btnFocus.onclick = () => {
  settings.focus = settings.focus ? 0 : 1;
  persistAll();
  applyFocus();
};

/* =========================
   Drawer
   ========================= */
function openDrawer(){
  drawer.classList.add("open");
  drawerOverlay.classList.add("open");
}
function closeDrawer(){
  drawer.classList.remove("open");
  drawerOverlay.classList.remove("open");
}
btnMenu.onclick = openDrawer;
btnQuickMenu.onclick = openDrawer;
btnCloseDrawer.onclick = closeDrawer;
drawerOverlay.onclick = closeDrawer;

/* =========================
   Notes modal
   ========================= */
function openNotes(){
  notesOverlay.style.display = "block";
  notesModal.style.display = "block";
  renderNotes();
}
function closeNotes(){
  notesOverlay.style.display = "none";
  notesModal.style.display = "none";
}
btnNotes.onclick = openNotes;
btnCloseNotes.onclick = closeNotes;
notesOverlay.onclick = closeNotes;

btnAddNote.onclick = () => {
  const txt = (noteInput.value||"").trim();
  if(!txt) return;
  notes.unshift({ id: uid(), ts: nowISO(), text: txt });
  noteInput.value = "";
  persistAll();
  renderNotes();
};
btnClearNoteInput.onclick = () => { noteInput.value=""; };

btnExportNotes.onclick = () => {
  downloadJSON(`eliminator-notes-${todayISO()}.json`, notes);
};

function renderNotes(){
  notesList.innerHTML = "";
  if(!notes.length){
    const p = document.createElement("p");
    p.className = "help";
    p.textContent = "Aucune note.";
    notesList.appendChild(p);
    return;
  }
  for(const n of notes){
    const d = document.createElement("div");
    d.className = "item";
    const left = document.createElement("div");
    left.className = "t";
    const name = document.createElement("div");
    name.className = "name";
    name.textContent = new Date(n.ts).toLocaleString();
    const sub = document.createElement("div");
    sub.className = "sub";
    sub.textContent = n.text;
    left.appendChild(name);
    left.appendChild(sub);

    const del = document.createElement("button");
    del.className = "iconBtn";
    del.textContent = "‚úï";
    del.title = "Supprimer";
    del.onclick = () => {
      notes = notes.filter(x=>x.id!==n.id);
      persistAll();
      renderNotes();
    };

    d.appendChild(left);
    d.appendChild(del);
    notesList.appendChild(d);
  }
}

/* =========================
   Celebration + Confetti
   ========================= */
const CELEB_LINES = [
  { big:"Gloire absolue.", small:"Tu viens de d√©ployer une efficacit√© ill√©gale dans 37 syst√®mes solaires." },
  { big:"Victoire nette.", small:"Les t√¢ches ont demand√© un duel. Elles ont perdu. Sans appel." },
  { big:"Triomphe clinique.", small:"Diagnostic: productivit√© fulgurante. Pronostic: excellent." },
  { big:"Conquistador¬∑rice.", small:"Tu as conquis l‚Äôinutile et lib√©r√© le n√©cessaire." },
  { big:"H√©g√©monie douce.", small:"Tu domines le chaos avec √©l√©gance et calme (presque suspect)." },
  { big:"Chef-d‚Äô≈ìuvre.", small:"Une action simple. Un empire de clart√©. Respect." },
  { big:"Souverain¬∑e.", small:"Les √©thorions reculent. Tu avances. Le monde cligne des yeux." },
  { big:"Mode Flow.", small:"Le cerveau ronronne. Les t√¢ches s‚Äô√©vaporent. Continue." }
];

function showCelebration(big, small){
  clearTimeout(celebrateTimer);
  celebrateBig.textContent = big || "Victoire";
  celebrateSmall.textContent = small || "";
  celebrateOverlay.style.display = "flex";
  const ms = clamp(parseInt(settings.celebrationAutoHideMs,10) || 9000, 2500, 20000);
  celebrateTimer = setTimeout(hideCelebration, ms);
}
function hideCelebration(){
  celebrateOverlay.style.display = "none";
}
celebrateOverlay.onclick = hideCelebration;

function celebrationProbability(){
  if(settings.celebrationMode === "off") return 0;
  if(settings.celebrationMode === "frequent") return 0.55;

  // surprise
  let p = 0.28;

  if(settings.motivation === "high") p -= 0.06;
  if(settings.motivation === "low")  p += 0.08;

  if(settings.fatigue === "high")   p += 0.12;
  if(settings.fatigue === "low")    p -= 0.04;

  const s = state.streak?.tasksSincePopup ?? 0;
  const minGap = clamp(parseInt(settings.celebrationMinGapTasks,10)||2, 1, 10);
  const maxGap = clamp(parseInt(settings.celebrationMaxGapTasks,10)||3, minGap, 20);

  if(s < minGap) p = 0;
  else{
    const ramp = clamp((s - minGap) / Math.max(1, (maxGap - minGap)), 0, 1);
    p = p + (0.25 * ramp);
  }

  const pMin = clamp(Number(settings.celebrationChanceMin)||0.10, 0, 1);
  const pMax = clamp(Number(settings.celebrationChanceMax)||0.55, 0, 1);
  return clamp(p, pMin, pMax);
}
function shouldShowCelebrationPopup(){
  return Math.random() < celebrationProbability();
}

function confettiBurst(){
  confettiCanvas.width = window.innerWidth;
  confettiCanvas.height = window.innerHeight;
  confettiCanvas.style.display = "block";

  const N = 120;
  const parts = Array.from({length:N}, () => {
    const x = confettiCanvas.width/2 + (Math.random()-0.5)*240;
    const y = confettiCanvas.height*0.30 + (Math.random()-0.5)*90;
    const vx = (Math.random()-0.5)*10;
    const vy = Math.random()*-10 - 6;
    const g = 0.35 + Math.random()*0.15;
    return { x,y,vx,vy,g,life: 60+Math.random()*25, w:2+Math.random()*4, h:8+Math.random()*10, r:Math.random()*Math.PI };
  });

  let frame = 0;
  function step(){
    frame++;
    confettiCtx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height);

    for(const p of parts){
      p.life -= 1;
      p.vy += p.g;
      p.x += p.vx;
      p.y += p.vy;
      p.r += 0.12;

      const a = Math.max(0, p.life/90);
      confettiCtx.globalAlpha = a;

      // sobre: blanc + 2 accents doux
      const u = Math.random();
      let fill = "rgba(255,255,255,.85)";
      if(u < 0.33) fill = "rgba(125,185,255,.70)";
      else if(u < 0.66) fill = "rgba(124,255,199,.60)";
      confettiCtx.fillStyle = fill;

      confettiCtx.save();
      confettiCtx.translate(p.x, p.y);
      confettiCtx.rotate(p.r);
      confettiCtx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
      confettiCtx.restore();
    }

    confettiCtx.globalAlpha = 1;

    if(frame < 80){
      requestAnimationFrame(step);
    }else{
      confettiCanvas.style.display = "none";
    }
  }
  step();
}
window.addEventListener("resize", () => {
  confettiCanvas.width = window.innerWidth;
  confettiCanvas.height = window.innerHeight;
});

/* =========================
   Tabs Rendering
   ========================= */
function renderTabs(){
  tabsEl.innerHTML = "";
  for(const t of TAB_DEFS){
    const b = document.createElement("button");
    b.className = "tab" + (t.key===activeTab ? " active": "");
    b.textContent = t.label;
    b.onclick = () => {
      activeTab = t.key;
      renderTabs();
      renderPanel();
    };
    tabsEl.appendChild(b);
  }
}

/* =========================
   Task Logic
   ========================= */
function recalcStartCounts(){
  // startCounts used for "restants / d√©part"
  const tasks = state.tasks.length + state.done.length;
  const eth = sumEth(state.tasks) + sumEth(state.done, true);
  state.startCounts = { tasks, eth };
}
function sumEth(list, useStart=false){
  let s=0;
  for(const t of list){
    const v = useStart ? (t.ethStart||0) : (t.ethLeft||0);
    s += v;
  }
  return s;
}
function pickNextTask(){
  // If set active, force order by queue
  if(state.activeSet && Array.isArray(state.activeSet.queueTaskIds) && state.activeSet.queueTaskIds.length){
    const nextId = state.activeSet.queueTaskIds[0];
    const t = state.tasks.find(x=>x.id===nextId);
    if(t) return t;
    // purge missing
    state.activeSet.queueTaskIds.shift();
  }

  if(!state.tasks.length) return null;

  if(settings.sortMode === "order"){
    // pinned first, then by createdAt
    const pinned = state.tasks.filter(t=>t.pinned);
    if(pinned.length) return pinned[0];
    return state.tasks[0];
  }else{
    // roulette among tasks, prefer pinned? We keep pinned in pool but lightly biased
    const pool = [...state.tasks];
    const pinned = pool.filter(t=>t.pinned);
    if(pinned.length && Math.random() < 0.55) return pinned[Math.floor(Math.random()*pinned.length)];
    return pool[Math.floor(Math.random()*pool.length)];
  }
}

function ensureCurrent(){
  if(!state.tasks.length){
    state.currentId = null;
    state.timer = { taskId:null, elapsedMs:0, running:false, startedAt:null };
    return;
  }
  if(state.currentId && state.tasks.some(t=>t.id===state.currentId)){
    // keep current
  }else{
    const t = pickNextTask();
    state.currentId = t ? t.id : null;
    // reset timer for new task
    state.timer = { taskId: state.currentId, elapsedMs:0, running: !!state.currentId, startedAt: Date.now() };
  }
}

function getCurrent(){
  if(!state.currentId) return null;
  return state.tasks.find(t=>t.id===state.currentId) || null;
}

function roulette(){
  if(!state.tasks.length) return;
  // pick randomly but not same if possible
  const current = getCurrent();
  let t = null;

  // if set active, roulette should still allow "reroll" but not break order:
  // We will allow reroll only if NOT in set mode
  if(state.activeSet){
    // In set mode, roulette just re-focus the next expected task
    ensureCurrent();
    renderAll();
    return;
  }

  if(state.tasks.length === 1){
    t = state.tasks[0];
  }else{
    for(let i=0;i<12;i++){
      const candidate = state.tasks[Math.floor(Math.random()*state.tasks.length)];
      if(!current || candidate.id !== current.id){ t = candidate; break; }
    }
    if(!t) t = state.tasks[0];
  }
  state.currentId = t.id;
  state.timer = { taskId: t.id, elapsedMs:0, running:true, startedAt: Date.now() };
}

function smashOne(){
  const t = getCurrent();
  if(!t) return;

  // Ensure timer running
  if(!state.timer.running || state.timer.taskId !== t.id){
    state.timer = { taskId: t.id, elapsedMs:0, running:true, startedAt: Date.now() };
  }

  t.ethLeft = clamp((t.ethLeft||1) - 1, 0, 999);

  // optional: small popup rarely on smash (not always)
  if(settings.celebrationMode !== "off"){
    const p = clamp(celebrationProbability()*0.35, 0, 0.25);
    if(Math.random() < p){
      const line = CELEB_LINES[Math.floor(Math.random()*CELEB_LINES.length)];
      showCelebration(line.big, "+1 √©thorion. Petit pas, grande conqu√™te.");
    }
  }

  // complete task
  if(t.ethLeft <= 0){
    completeTask(t, "smash");
  }else{
    persistAll();
    renderAll();
  }
}

function completeTask(t, source){
  // Confetti always at end of task
  confettiBurst();

  // snapshot for done
  const doneTask = {
    ...t,
    doneAt: nowISO(),
    doneSource: source,
    elapsedMs: currentTaskElapsedMs()
  };

  // remove from tasks
  state.tasks = state.tasks.filter(x=>x.id!==t.id);
  state.done.unshift(doneTask);

  // set queue advance
  if(state.activeSet && state.activeSet.queueTaskIds && state.activeSet.queueTaskIds[0] === t.id){
    state.activeSet.queueTaskIds.shift();
    if(state.activeSet.queueTaskIds.length === 0){
      // set finished
      state.activeSet = null;
    }
  }

  // history log (daily)
  pushHistoryEvent({
    type:"task_done",
    dayISO: todayISO(),
    taskId: doneTask.id,
    title: doneTask.title,
    cat: doneTask.cat,
    ethStart: doneTask.ethStart,
    elapsedMs: doneTask.elapsedMs || 0
  });

  // streak
  state.streak.tasksSinceStart = (state.streak.tasksSinceStart||0) + 1;
  state.streak.tasksSincePopup = (state.streak.tasksSincePopup||0) + 1;

  // popup surprise sometimes
  if(shouldShowCelebrationPopup()){
    const line = CELEB_LINES[Math.floor(Math.random()*CELEB_LINES.length)];
    showCelebration(line.big, line.small);
    state.streak.tasksSincePopup = 0;
  }

  // choose next
  state.currentId = null;
  state.timer = { taskId:null, elapsedMs:0, running:false, startedAt:null };
  ensureCurrent();
  persistAll();
  renderAll();
}

function currentTaskElapsedMs(){
  if(!state.timer || !state.timer.taskId) return 0;
  return state.timer.elapsedMs || 0;
}

/* =========================
   History / daily rollover
   ========================= */
function pushHistoryEvent(evt){
  history.unshift({ id: uid(), ts: nowISO(), ...evt });
  // keep reasonable size
  if(history.length > 5000) history.length = 5000;
  saveJSON(K.history, history);
}

function maybeRolloverDay(){
  const today = todayISO();
  if(state.dayStartISO !== today){
    // new day: keep tasks (you wanted history daily + weekly)
    // we just mark the day switch event
    pushHistoryEvent({ type:"day_rollover", from: state.dayStartISO, to: today });
    state.dayStartISO = today;

    // reset habits day if you want separate daily boxes
    // (we store habits with dayISO; if day changed, create new day boxes when needed)

    persistAll();
  }
}

/* =========================
   Reset
   ========================= */
btnReset.onclick = () => {
  // reset tasks/done/timer/streak/current/set, but keep notes/kiff/habits/history
  state.tasks = [];
  state.done = [];
  state.currentId = null;
  state.startCounts = { tasks:0, eth:0 };
  state.timer = { taskId:null, elapsedMs:0, running:false, startedAt:null };
  state.streak = { tasksSincePopup:0, tasksSinceStart:0 };
  state.activeSet = null;

  pushHistoryEvent({ type:"reset", dayISO: todayISO() });

  persistAll();
  renderAll();
  renderPanel();
};

/* =========================
   Tick timer (elapsed)
   ========================= */
function startTicker(){
  stopTicker();
  tickTimer = setInterval(() => {
    maybeRolloverDay();
    const cur = getCurrent();
    if(cur && state.timer && state.timer.taskId === cur.id && state.timer.running){
      const now = Date.now();
      const base = state.timer.startedAt || now;
      state.timer.elapsedMs = (now - base);
      saveJSON(K.state, state);
      renderHUD();
    }else{
      renderHUD();
    }
  }, 500);
}
function stopTicker(){
  if(tickTimer) clearInterval(tickTimer);
  tickTimer = null;
}

/* =========================
   Render: HUD + Main
   ========================= */
function renderHUD(){
  const totalTasks0 = state.startCounts.tasks || (state.tasks.length + state.done.length);
  const totalEth0 = state.startCounts.eth || (sumEth(state.tasks) + sumEth(state.done,true));

  const tasksLeft = state.tasks.length;
  const ethLeft = sumEth(state.tasks);

  hudTasks.innerHTML = `<b>${tasksLeft}</b> / ${totalTasks0} t√¢ches`;
  hudEth.innerHTML   = `<b>${ethLeft}</b> / ${totalEth0} √©thorions`;
  hudDone.innerHTML  = `<b>${state.done.length}</b> faites`;

  const cur = getCurrent();
  if(cur){
    hudTimer.innerHTML = `temps <b>${fmtTime(state.timer?.elapsedMs||0)}</b>`;
  }else{
    hudTimer.innerHTML = `temps <b>00:00</b>`;
  }
}

function renderMain(){
  ensureCurrent();

  const totalTasks0 = state.startCounts.tasks || (state.tasks.length + state.done.length);
  const totalEth0 = state.startCounts.eth || (sumEth(state.tasks) + sumEth(state.done,true));
  const tasksLeft = state.tasks.length;

  // Task progress uses: % done = 1 - tasksLeft/totalTasks0
  const pct = totalTasks0 ? (1 - (tasksLeft/totalTasks0)) : 0;
  const p = clamp(Math.round(pct*100), 0, 100);
  taskFill.style.width = `${p}%`;
  taskPct.textContent = `${p}%`;

  const cur = getCurrent();
  if(!cur){
    currentTitle.textContent = "Aucune t√¢che";
    currentMeta.innerHTML = `<span>Importe des t√¢ches dans Inbox.</span>`;
    ethFill.style.width = `0%`;
    btnSmash.disabled = true;
    btnRoulette.disabled = true;
    return;
  }

  btnSmash.disabled = false;
  btnRoulette.disabled = false;

  currentTitle.textContent = cur.title;

  const minsLeft = minutesFromEth(cur.ethLeft||0);
  const minsStart = minutesFromEth(cur.ethStart||0);
  const meta = [];

  // minimal meta, but useful
  meta.push(`√âthorions: ${cur.ethLeft}/${cur.ethStart} (${fmtMin(minsLeft)} restants)`);
  if(cur.cat) meta.push(`Cat: ${cur.cat}`);
  if(state.activeSet) meta.push(`Set actif: ${state.activeSet.setName}`);

  currentMeta.innerHTML = meta.map(x=>`<span>${safeText(x)}</span>`).join(" ¬∑ ");

  const ethPct = cur.ethStart ? ((cur.ethLeft||0)/(cur.ethStart||1)) : 0;
  ethFill.style.width = `${clamp(Math.round(ethPct*100), 0, 100)}%`;

  // accessibility: update smash text contrast; we already use CSS variables.
}

/* =========================
   Render Panel content
   ========================= */
function mkCard(title, innerHTML){
  const c = document.createElement("div");
  c.className = "card";
  const h = document.createElement("h3");
  h.textContent = title;
  c.appendChild(h);
  const d = document.createElement("div");
  d.innerHTML = innerHTML;
  c.appendChild(d);
  return c;
}

function renderPanel(){
  panelEl.innerHTML = "";
  if(activeTab==="inbox") panelEl.appendChild(buildInboxPanel());
  if(activeTab==="liste") panelEl.appendChild(buildListPanel());
  if(activeTab==="sets") panelEl.appendChild(buildSetsPanel());
  if(activeTab==="kiff") panelEl.appendChild(buildKiffPanel());
  if(activeTab==="habits") panelEl.appendChild(buildHabitsPanel());
  if(activeTab==="hist") panelEl.appendChild(buildHistoryPanel());
  if(activeTab==="rapport") panelEl.appendChild(buildReportPanel());
  if(activeTab==="params") panelEl.appendChild(buildParamsPanel());
}

/* =========================
   Inbox: import parsing (caps category)
   ========================= */
function buildInboxPanel(){
  const wrap = document.createElement("div");

  const c1 = mkCard("Importer", `
    <p class="help">
      Format:
      <br>‚Äî Une ligne en MAJUSCULES = cat√©gorie
      <br>‚Äî Les lignes dessous = t√¢ches de cette cat√©gorie
      <br>‚Äî Option: "T√¢che - 3" (3 √©thorions) ou "T√¢che 3"
    </p>
    <textarea id="inboxText" placeholder="EX:\nAPPELS\nAppeler Hugo - 2\nAppeler Samira\nADMIN\nRapport X - 6"></textarea>
    <div class="row" style="margin-top:10px;">
      <button class="btn primary" id="btnImport">Importer</button>
      <button class="btn" id="btnClearInbox">Effacer</button>
    </div>
    <div class="row" style="margin-top:10px;">
      <button class="btn" id="btnExportTasks">Exporter t√¢ches</button>
      <button class="btn" id="btnExportDone">Exporter fait</button>
    </div>
  `);

  const c2 = mkCard("Aper√ßu", `
    <div class="help" id="importPreview">Aucun aper√ßu.</div>
  `);

  wrap.appendChild(c1);
  wrap.appendChild(c2);

  setTimeout(() => {
    const inboxText = document.getElementById("inboxText");
    const preview = document.getElementById("importPreview");

    function previewParse(){
      const txt = inboxText.value || "";
      const lines = txt.split(/\r?\n/);
      let cat = "";
      let out = [];
      for(const raw of lines){
        const line = raw.trim();
        if(!line) continue;
        if(isAllCaps(line)){
          cat = line;
          continue;
        }
        const parsed = parseTaskLine(line);
        if(!parsed || !parsed.title) continue;
        out.push({ cat: cat || "INBOX", title: parsed.title, eth: parsed.eth });
      }
      if(!out.length){
        preview.textContent = "Aucun √©l√©ment d√©tect√©.";
        return;
      }
      const cats = uniq(out.map(x=>x.cat));
      preview.innerHTML = `${out.length} t√¢ches d√©tect√©es ¬∑ ${cats.length} cat√©gories`;
    }

    inboxText.addEventListener("input", previewParse);
    previewParse();

    document.getElementById("btnClearInbox").onclick = () => {
      inboxText.value = "";
      previewParse();
    };

    document.getElementById("btnImport").onclick = () => {
      const txt = inboxText.value || "";
      const lines = txt.split(/\r?\n/);
      let cat = "";
      const created = [];
      for(const raw of lines){
        const line = raw.trim();
        if(!line) continue;
        if(isAllCaps(line)){
          cat = line;
          continue;
        }
        const parsed = parseTaskLine(line);
        if(!parsed || !parsed.title) continue;
        const t = {
          id: uid(),
          title: parsed.title,
          cat: cat || "INBOX",
          ethStart: parsed.eth,
          ethLeft: parsed.eth,
          pinned: false,
          createdAt: nowISO()
        };
        created.push(t);
      }
      if(!created.length) return;

      state.tasks = [...state.tasks, ...created];
      recalcStartCounts();
      state.currentId = null;
      ensureCurrent();

      pushHistoryEvent({ type:"import", dayISO: todayISO(), count: created.length });

      persistAll();
      renderAll();
      renderPanel();
    };

    document.getElementById("btnExportTasks").onclick = () => {
      downloadJSON(`eliminator-tasks-${todayISO()}.json`, state.tasks);
    };
    document.getElementById("btnExportDone").onclick = () => {
      downloadJSON(`eliminator-done-${todayISO()}.json`, state.done);
    };
  }, 0);

  return wrap;
}

/* =========================
   Liste: minimal actions + mark done
   ========================= */
function buildListPanel(){
  const wrap = document.createElement("div");

  const c1 = mkCard("T√¢ches (pool actif)", `
    <div class="row">
      <select id="sortMode">
        <option value="roulette">Mode: roulette</option>
        <option value="order">Mode: ordre</option>
      </select>
      <button class="btn" id="btnRecalc">Recalcul d√©part</button>
    </div>
    <div class="row" style="margin-top:10px;">
      <button class="btn" id="btnSelectCats">Filtrer cat√©gories</button>
      <button class="btn" id="btnClearCatFilter">Tout afficher</button>
    </div>
    <div class="list" id="taskList"></div>
  `);

  wrap.appendChild(c1);

  setTimeout(() => {
    const sortMode = document.getElementById("sortMode");
    sortMode.value = settings.sortMode || "roulette";
    sortMode.onchange = () => {
      settings.sortMode = sortMode.value;
      persistAll();
    };

    document.getElementById("btnRecalc").onclick = () => {
      recalcStartCounts();
      persistAll();
      renderAll();
    };

    document.getElementById("btnSelectCats").onclick = () => {
      const cats = uniq(state.tasks.map(t=>t.cat || "INBOX")).sort((a,b)=>a.localeCompare(b));
      const chosen = prompt(
        "Cat√©gories √† inclure (s√©par√©es par des virgules).\nDisponibles:\n" + cats.join(", "),
        (settings.activeCats && settings.activeCats.length) ? settings.activeCats.join(", ") : ""
      );
      if(chosen===null) return;
      const arr = chosen.split(",").map(x=>x.trim()).filter(Boolean);
      settings.activeCats = arr.length ? arr : null;
      persistAll();
      renderAll();
      renderPanel();
    };

    document.getElementById("btnClearCatFilter").onclick = () => {
      settings.activeCats = null;
      persistAll();
      renderAll();
      renderPanel();
    };

    renderTaskList();
  }, 0);

  return wrap;
}

function filteredTasks(){
  if(!settings.activeCats || !settings.activeCats.length) return state.tasks;
  const set = new Set(settings.activeCats);
  return state.tasks.filter(t => set.has(t.cat || "INBOX"));
}

function renderTaskList(){
  const list = document.getElementById("taskList");
  if(!list) return;
  list.innerHTML = "";

  const tasks = filteredTasks();

  if(!tasks.length){
    const p = document.createElement("p");
    p.className = "help";
    p.textContent = "Aucune t√¢che dans la s√©lection.";
    list.appendChild(p);
    return;
  }

  for(let i=0;i<tasks.length;i++){
    const t = tasks[i];
    const row = document.createElement("div");
    row.className = "item";

    const left = document.createElement("div");
    left.className = "t";

    const name = document.createElement("div");
    name.className = "name";
    name.textContent = t.title;

    const sub = document.createElement("div");
    sub.className = "sub";
    sub.textContent = `${t.cat || "INBOX"} ¬∑ ${t.ethLeft}/${t.ethStart} √©thorions` + (t.pinned ? " ¬∑ √©pingl√©e" : "");

    left.appendChild(name);
    left.appendChild(sub);

    // up/down/edit + delete + mark done
    const up = document.createElement("button");
    up.className = "iconBtn";
    up.textContent = "‚Üë";
    up.title = "Monter (prioriser)";
    up.onclick = () => {
      const idx = state.tasks.findIndex(x=>x.id===t.id);
      if(idx>0){
        const tmp = state.tasks[idx-1];
        state.tasks[idx-1] = state.tasks[idx];
        state.tasks[idx] = tmp;
        persistAll();
        renderPanel();
      }
    };

    const down = document.createElement("button");
    down.className = "iconBtn";
    down.textContent = "‚Üì";
    down.title = "Descendre";
    down.onclick = () => {
      const idx = state.tasks.findIndex(x=>x.id===t.id);
      if(idx>=0 && idx<state.tasks.length-1){
        const tmp = state.tasks[idx+1];
        state.tasks[idx+1] = state.tasks[idx];
        state.tasks[idx] = tmp;
        persistAll();
        renderPanel();
      }
    };

    const edit = document.createElement("button");
    edit.className = "iconBtn";
    edit.textContent = "‚úé";
    edit.title = "√âditer";
    edit.onclick = () => {
      const newTitle = prompt("Nouveau titre", t.title);
      if(newTitle===null) return;
      t.title = (newTitle||"").trim() || t.title;

      const newEth = prompt("√âthorions (nombre)", String(t.ethStart||1));
      if(newEth!==null){
        const n = clamp(parseInt(newEth,10)||t.ethStart||1, 1, 999);
        // adjust proportionally: keep same remaining ratio if possible
        const ratio = (t.ethStart>0) ? (t.ethLeft/t.ethStart) : 1;
        t.ethStart = n;
        t.ethLeft = clamp(Math.round(n*ratio), 0, n);
      }

      persistAll();
      renderAll();
      renderPanel();
    };

    const pin = document.createElement("button");
    pin.className = "iconBtn";
    pin.textContent = "‚åÅ";
    pin.title = "√âpingler / d√©s√©pingler";
    pin.onclick = () => {
      t.pinned = !t.pinned;
      persistAll();
      renderAll();
      renderPanel();
    };

    const doneBtn = document.createElement("button");
    doneBtn.className = "iconBtn";
    doneBtn.textContent = "‚úì";
    doneBtn.title = "Marquer comme d√©j√† d√©gomm√©e";
    doneBtn.onclick = () => {
      // Mark as done immediately, no confetti (this is administrative)
      const fake = { ...t, ethLeft:0 };
      state.currentId = (state.currentId===t.id) ? null : state.currentId;
      state.tasks = state.tasks.filter(x=>x.id!==t.id);
      state.done.unshift({ ...fake, doneAt: nowISO(), doneSource:"manual_mark_done", elapsedMs:0 });

      pushHistoryEvent({ type:"task_done", dayISO: todayISO(), taskId: t.id, title: t.title, cat: t.cat, ethStart: t.ethStart, elapsedMs:0 });

      // advance set queue if needed
      if(state.activeSet && state.activeSet.queueTaskIds && state.activeSet.queueTaskIds[0] === t.id){
        state.activeSet.queueTaskIds.shift();
        if(state.activeSet.queueTaskIds.length === 0) state.activeSet = null;
      }

      recalcStartCounts();
      ensureCurrent();
      persistAll();
      renderAll();
      renderPanel();
    };

    const del = document.createElement("button");
    del.className = "iconBtn";
    del.textContent = "‚úï";
    del.title = "Supprimer";
    del.onclick = () => {
      state.tasks = state.tasks.filter(x=>x.id!==t.id);
      if(state.currentId===t.id) state.currentId=null;
      ensureCurrent();
      recalcStartCounts();
      persistAll();
      renderAll();
      renderPanel();
    };

    row.appendChild(left);
    row.appendChild(up);
    row.appendChild(down);
    row.appendChild(edit);
    row.appendChild(pin);
    row.appendChild(doneBtn);
    row.appendChild(del);
    list.appendChild(row);
  }
}

/* =========================
   Sets panel (hospital/consult)
   ========================= */
function buildSetsPanel(){
  const wrap = document.createElement("div");

  const c1 = mkCard("Sets", `
    <p class="help">
      Active un set pour le rendre prioritaire et le faire dans l‚Äôordre.
      Tu peux g√©n√©rer N patients (Patient 1 ‚Üí √©tapes‚Ä¶).
    </p>

    <div class="row" style="margin-top:10px;">
      <select id="setSelect"></select>
      <input id="setPatients" type="number" min="1" max="60" value="4" />
    </div>

    <div class="row" style="margin-top:10px;">
      <button class="btn primary" id="btnActivateSet">Activer</button>
      <button class="btn danger" id="btnStopSet">Stop</button>
      <button class="btn" id="btnEditSet">Modifier</button>
    </div>

    <div style="margin-top:12px;" class="help" id="setStatus"></div>
  `);

  const c2 = mkCard("√âditeur", `
    <input id="setName" placeholder="Nom du set" />
    <textarea id="setSteps" style="margin-top:10px; min-height:140px;"
      placeholder="1 ligne = une √©tape (format : Libell√© - eth)\nEx:\nVoir patient - 1\nNote - 1\nTraitement - 1\nDossier - 2"></textarea>

    <div class="row" style="margin-top:10px;">
      <button class="btn primary" id="btnSaveSet">Enregistrer</button>
      <button class="btn" id="btnNewSet">Nouveau</button>
      <button class="btn danger" id="btnDeleteSet">Supprimer</button>
    </div>
    <p class="help" style="margin-top:10px;">
      L‚Äô√©diteur est volontairement simple pour rester utilisable sans usine √† gaz.
    </p>
  `);

  c2.style.display = "none";
  wrap.appendChild(c1);
  wrap.appendChild(c2);

  setTimeout(() => {
    const setSelect = document.getElementById("setSelect");
    const setPatients = document.getElementById("setPatients");
    const setStatus = document.getElementById("setStatus");

    const setName = document.getElementById("setName");
    const setSteps = document.getElementById("setSteps");
    const btnEditSet = document.getElementById("btnEditSet");
    const btnSaveSet = document.getElementById("btnSaveSet");
    const btnNewSet = document.getElementById("btnNewSet");
    const btnDeleteSet = document.getElementById("btnDeleteSet");

    function refreshSelect(){
      setSelect.innerHTML = "";
      for(const s of sets){
        const opt = document.createElement("option");
        opt.value = s.id;
        opt.textContent = s.name;
        setSelect.appendChild(opt);
      }
    }
    function getSelectedSet(){
      const id = setSelect.value;
      return sets.find(x=>x.id===id) || sets[0];
    }
    function formatStepsText(steps){
      return (steps||[]).map(st => `${st.label} - ${st.eth}`).join("\n");
    }
    function parseStepsText(text){
      const out = [];
      const lines = (text||"").split(/\r?\n/).map(x=>x.trim()).filter(Boolean);
      for(const ln of lines){
        let label = ln;
        let eth = 1;
        const m = ln.match(/\s*-\s*(\d+)\s*$/);
        if(m){
          eth = clamp(parseInt(m[1],10)||1,1,999);
          label = ln.replace(/\s*-\s*\d+\s*$/,"").trim();
        }
        if(label) out.push({ label, eth });
      }
      return out.length ? out : [{ label:"√âtape", eth:1 }];
    }
    function renderStatus(){
      if(state.activeSet){
        setStatus.textContent = `Set actif: ${state.activeSet.setName || "‚Äî"} ¬∑ reste ${state.activeSet.queueTaskIds.length} t√¢che(s).`;
      }else{
        setStatus.textContent = `Aucun set actif.`;
      }
    }

    function activateSet(){
      const s = getSelectedSet();
      const n = clamp(parseInt(setPatients.value,10)||1, 1, 60);

      const cat = `SET ¬∑ ${s.name}`;
      const created = [];
      const queue = [];

      for(let i=1;i<=n;i++){
        const pLabel = `Patient ${i}`;
        for(const st of (s.steps||[])){
          const title = `${pLabel} ‚Äî ${st.label}`;
          const eth = clamp(parseInt(st.eth,10)||1,1,999);
          const t = {
            id: uid(),
            title,
            cat,
            ethStart: eth,
            ethLeft: eth,
            pinned: false,
            createdAt: nowISO(),
            setMeta: { setId: s.id, patient: i, step: st.label }
          };
          created.push(t);
          queue.push(t.id);
        }
      }

      // priority: insert in front
      state.tasks = [...created, ...state.tasks];

      state.activeSet = {
        setId: s.id,
        setName: s.name,
        queueTaskIds: queue,
        startedAt: nowISO()
      };

      settings.sortMode = "order"; // set forces order (but not spammed on UI)
      recalcStartCounts();
      state.currentId = null;
      state.timer = { taskId:null, elapsedMs:0, running:false, startedAt:null };
      ensureCurrent();

      pushHistoryEvent({ type:"set_activated", dayISO: todayISO(), setId:s.id, setName:s.name, patients:n });

      persistAll();
      renderAll();
      renderPanel();
    }

    function stopSet(){
      if(state.activeSet){
        pushHistoryEvent({ type:"set_stopped", dayISO: todayISO(), setName: state.activeSet.setName });
      }
      state.activeSet = null;
      persistAll();
      renderAll();
      renderPanel();
    }

    btnEditSet.onclick = () => {
      const s = getSelectedSet();
      setName.value = s.name;
      setSteps.value = formatStepsText(s.steps);
      c2.style.display = (c2.style.display==="none") ? "" : "none";
    };

    btnSaveSet.onclick = () => {
      const s = getSelectedSet();
      s.name = (setName.value || s.name).trim() || s.name;
      s.steps = parseStepsText(setSteps.value);
      persistAll();
      refreshSelect();
      renderPanel();
    };

    btnNewSet.onclick = () => {
      const id = "set_" + uid();
      const s = {
        id,
        name: "Nouveau set",
        type:"custom",
        steps: [{label:"√âtape", eth:1}]
      };
      sets.push(s);
      persistAll();
      refreshSelect();
      setSelect.value = id;
      setName.value = s.name;
      setSteps.value = formatStepsText(s.steps);
      c2.style.display = "";
    };

    btnDeleteSet.onclick = () => {
      const s = getSelectedSet();
      if(s.id==="set_hosp" || s.id==="set_cons"){
        alert("Sets de base non supprimables.");
        return;
      }
      sets = sets.filter(x=>x.id!==s.id);
      persistAll();
      refreshSelect();
      renderPanel();
    };

    document.getElementById("btnActivateSet").onclick = activateSet;
    document.getElementById("btnStopSet").onclick = stopSet;

    refreshSelect();
    renderStatus();
  }, 0);

  return wrap;
}

/* =========================
   Kiffance: 4 cat√©gories (5/10/15/25+)
   ========================= */
function buildKiffPanel(){
  const wrap = document.createElement("div");

  const c1 = mkCard("Kiffance ‚Äî suggestions", `
    <p class="help">
      4 cat√©gories: 5 min, 10 min, 15 min, 25+ min.
      Rafra√Æchir pour tirer une suggestion.
    </p>

    <div class="row" style="margin-top:10px;">
      <select id="kiffCat">
        <option value="5">5 minutes</option>
        <option value="10">10 minutes</option>
        <option value="15">15 minutes</option>
        <option value="25">25+ minutes</option>
      </select>
      <button class="btn primary" id="btnKiffRefresh">Rafra√Æchir</button>
    </div>

    <div class="card" style="margin-top:10px; margin-bottom:0;">
      <h3>Suggestion</h3>
      <p class="help" id="kiffSuggestion">‚Äî</p>
      <div class="row" style="margin-top:10px;">
        <button class="btn" id="btnKiffToTasks">Ajouter √† la liste</button>
        <button class="btn" id="btnKiffCopy">Copier</button>
      </div>
    </div>
  `);

  const c2 = mkCard("Banque (ajouter / supprimer)", `
    <div class="row">
      <select id="kiffCat2">
        <option value="5">5 minutes</option>
        <option value="10">10 minutes</option>
        <option value="15">15 minutes</option>
        <option value="25">25+ minutes</option>
      </select>
      <button class="btn" id="btnKiffShow">Voir</button>
    </div>

    <textarea id="kiffAdd" style="margin-top:10px; min-height:90px;" placeholder="Ajouter des lignes (1 id√©e par ligne)"></textarea>
    <div class="row" style="margin-top:10px;">
      <button class="btn primary" id="btnKiffAdd">Ajouter</button>
      <button class="btn danger" id="btnKiffReset">Reset banque</button>
    </div>

    <div class="list" id="kiffList" style="margin-top:10px;"></div>
  `);

  wrap.appendChild(c1);
  wrap.appendChild(c2);

  setTimeout(() => {
    const kiffCat = document.getElementById("kiffCat");
    const kiffSuggestion = document.getElementById("kiffSuggestion");
    const kiffCat2 = document.getElementById("kiffCat2");
    const kiffList = document.getElementById("kiffList");

    let currentSuggestion = "";

    function pickSuggestion(cat){
      const arr = kiffBank[String(cat)] || [];
      if(!arr.length) return "Banque vide pour cette cat√©gorie.";
      return arr[Math.floor(Math.random()*arr.length)];
    }

    function refresh(){
      const cat = kiffCat.value;
      currentSuggestion = pickSuggestion(cat);
      kiffSuggestion.textContent = currentSuggestion;
    }

    document.getElementById("btnKiffRefresh").onclick = refresh;

    document.getElementById("btnKiffToTasks").onclick = () => {
      if(!currentSuggestion) refresh();
      const cat = "KIFFANCE";
      const eth = (kiffCat.value==="5") ? 1 :
                  (kiffCat.value==="10") ? 2 :
                  (kiffCat.value==="15") ? 3 : 5;
      state.tasks.push({
        id: uid(),
        title: currentSuggestion,
        cat,
        ethStart: eth,
        ethLeft: eth,
        pinned: false,
        createdAt: nowISO()
      });
      recalcStartCounts();
      ensureCurrent();
      pushHistoryEvent({ type:"kiff_to_task", dayISO: todayISO(), cat:kiffCat.value });
      persistAll();
      renderAll();
      renderPanel();
    };

    document.getElementById("btnKiffCopy").onclick = async () => {
      if(!currentSuggestion) refresh();
      try{ await navigator.clipboard.writeText(currentSuggestion); }catch(e){}
    };

    function renderBankList(cat){
      kiffList.innerHTML = "";
      const arr = (kiffBank[String(cat)] || []);
      if(!arr.length){
        const p = document.createElement("p");
        p.className = "help";
        p.textContent = "Banque vide.";
        kiffList.appendChild(p);
        return;
      }
      arr.forEach((txt, idx) => {
        const it = document.createElement("div");
        it.className = "item";
        const t = document.createElement("div");
        t.className = "t";
        const name = document.createElement("div");
        name.className = "name";
        name.textContent = txt;
        t.appendChild(name);

        const del = document.createElement("button");
        del.className = "iconBtn";
        del.textContent = "‚úï";
        del.title = "Supprimer";
        del.onclick = () => {
          kiffBank[String(cat)] = kiffBank[String(cat)].filter((_,i)=>i!==idx);
          persistAll();
          renderBankList(cat);
        };

        it.appendChild(t);
        it.appendChild(del);
        kiffList.appendChild(it);
      });
    }

    document.getElementById("btnKiffShow").onclick = () => {
      renderBankList(kiffCat2.value);
    };

    document.getElementById("btnKiffAdd").onclick = () => {
      const cat = kiffCat2.value;
      const txt = (document.getElementById("kiffAdd").value || "");
      const lines = txt.split(/\r?\n/).map(x=>x.trim()).filter(Boolean);
      if(!lines.length) return;
      kiffBank[String(cat)] = (kiffBank[String(cat)] || []).concat(lines);
      document.getElementById("kiffAdd").value = "";
      persistAll();
      renderBankList(cat);
    };

    document.getElementById("btnKiffReset").onclick = () => {
      kiffBank = structuredClone(DEFAULT_KIFF);
      persistAll();
      renderBankList(kiffCat2.value);
      refresh();
    };

    refresh();
    renderBankList("5");
  }, 0);

  return wrap;
}

/* =========================
   Habits: 10 boxes + report
   ========================= */
function buildHabitsPanel(){
  const wrap = document.createElement("div");
  const c1 = mkCard("Suivi des habitudes", `
    <p class="help">
      Une habitude = une ligne. 10 cases = progression (au choix: journ√©e, semaine, etc.).
      Pas de c√©l√©bration √† l‚Äôencodage, c‚Äôest administratif.
    </p>
    <div class="row" style="margin-top:10px;">
      <input id="habitName" placeholder="Nom (ex: verres d‚Äôeau / marche / dossier X)" />
      <button class="btn primary" id="btnAddHabit">Ajouter</button>
    </div>
    <div class="list" id="habitList" style="margin-top:10px;"></div>
  `);

  wrap.appendChild(c1);

  setTimeout(() => {
    document.getElementById("btnAddHabit").onclick = () => {
      const name = (document.getElementById("habitName").value||"").trim();
      if(!name) return;
      habits.unshift({
        id: uid(),
        name,
        dayISO: todayISO(),
        boxes: Array.from({length:10}, ()=>false)
      });
      document.getElementById("habitName").value = "";
      persistAll();
      renderPanel();
    };

    renderHabitsList();
  }, 0);

  return wrap;
}

function renderHabitsList(){
  const list = document.getElementById("habitList");
  if(!list) return;
  list.innerHTML = "";

  if(!habits.length){
    const p = document.createElement("p");
    p.className = "help";
    p.textContent = "Aucune habitude.";
    list.appendChild(p);
    return;
  }

  for(const h of habits){
    const row = document.createElement("div");
    row.className = "item";

    const left = document.createElement("div");
    left.className = "t";

    const name = document.createElement("div");
    name.className = "name";
    name.textContent = h.name;

    const sub = document.createElement("div");
    sub.className = "sub";
    const done = (h.boxes||[]).filter(Boolean).length;
    sub.textContent = `${done}/10 ¬∑ ${h.dayISO}`;

    left.appendChild(name);
    left.appendChild(sub);

    const boxesWrap = document.createElement("div");
    boxesWrap.style.display = "flex";
    boxesWrap.style.gap = "6px";
    boxesWrap.style.alignItems = "center";

    for(let i=0;i<10;i++){
      const b = document.createElement("button");
      b.className = "iconBtn";
      b.style.width = "28px";
      b.style.height = "28px";
      b.textContent = (h.boxes && h.boxes[i]) ? "‚ñ†" : "‚ñ°";
      b.title = `Case ${i+1}`;
      b.onclick = () => {
        h.boxes[i] = !h.boxes[i];
        persistAll();
        renderHabitsList();
      };
      boxesWrap.appendChild(b);
    }

    const reset = document.createElement("button");
    reset.className = "iconBtn";
    reset.textContent = "‚Ü∫";
    reset.title = "Reset cases";
    reset.onclick = () => {
      h.boxes = Array.from({length:10}, ()=>false);
      persistAll();
      renderHabitsList();
    };

    const del = document.createElement("button");
    del.className = "iconBtn";
    del.textContent = "‚úï";
    del.title = "Supprimer";
    del.onclick = () => {
      habits = habits.filter(x=>x.id!==h.id);
      persistAll();
      renderHabitsList();
    };

    row.appendChild(left);
    row.appendChild(boxesWrap);
    row.appendChild(reset);
    row.appendChild(del);

    list.appendChild(row);
  }
}

/* =========================
   History panel: timeline + calendar
   ========================= */
function buildHistoryPanel(){
  const wrap = document.createElement("div");

  const c1 = mkCard("Historique (timeline)", `
    <div class="row">
      <button class="btn" id="btnExportHistory">Exporter</button>
      <button class="btn" id="btnClearHistory">Vider</button>
    </div>
    <div class="list" id="histList" style="margin-top:10px;"></div>
  `);

  const c2 = mkCard("Calendrier (mois)", `
    <div class="row">
      <button class="btn" id="btnPrevMonth">‚Üê</button>
      <div class="help" id="calTitle" style="text-align:center;"></div>
      <button class="btn" id="btnNextMonth">‚Üí</button>
    </div>
    <div class="calGrid" id="calGrid"></div>
    <p class="help" style="margin-top:10px;">
      Chaque case affiche t√¢ches faites / √©thorions faits (approxim√© via ethStart).
    </p>
  `);

  wrap.appendChild(c1);
  wrap.appendChild(c2);

  setTimeout(() => {
    document.getElementById("btnExportHistory").onclick = () => downloadJSON(`eliminator-history-${todayISO()}.json`, history);
    document.getElementById("btnClearHistory").onclick = () => {
      if(confirm("Vider l'historique ?")){
        history = [];
        persistAll();
        renderPanel();
      }
    };

    renderHistoryList();

    // calendar
    let view = new Date();
    view.setDate(1);

    function renderCal(){
      const calTitle = document.getElementById("calTitle");
      const grid = document.getElementById("calGrid");
      grid.innerHTML = "";

      const y = view.getFullYear();
      const m = view.getMonth();
      calTitle.textContent = view.toLocaleString(undefined, { month:"long", year:"numeric" });

      const firstDay = new Date(y,m,1);
      const startWeekday = (firstDay.getDay()+6)%7; // monday=0
      const daysInMonth = new Date(y,m+1,0).getDate();

      // map daily totals from history
      const map = {}; // dayISO -> {tasks, eth}
      for(const e of history){
        if(e.type==="task_done" && e.dayISO){
          map[e.dayISO] = map[e.dayISO] || { tasks:0, eth:0 };
          map[e.dayISO].tasks += 1;
          map[e.dayISO].eth += (e.ethStart||0);
        }
      }

      // leading blanks
      for(let i=0;i<startWeekday;i++){
        const c = document.createElement("div");
        c.className = "calCell";
        c.style.opacity = "0.45";
        grid.appendChild(c);
      }

      for(let d=1; d<=daysInMonth; d++){
        const iso = `${y}-${String(m+1).padStart(2,"0")}-${String(d).padStart(2,"0")}`;
        const c = document.createElement("div");
        c.className = "calCell";

        const dd = document.createElement("div");
        dd.className = "d";
        dd.textContent = String(d);

        const val = map[iso];
        const kk = document.createElement("div");
        kk.className = "k";
        kk.textContent = val ? `${val.tasks} / ${val.eth}` : "‚Äî";

        c.appendChild(dd);
        c.appendChild(kk);
        grid.appendChild(c);
      }
    }

    document.getElementById("btnPrevMonth").onclick = () => { view.setMonth(view.getMonth()-1); renderCal(); };
    document.getElementById("btnNextMonth").onclick = () => { view.setMonth(view.getMonth()+1); renderCal(); };

    renderCal();
  }, 0);

  return wrap;
}

function renderHistoryList(){
  const list = document.getElementById("histList");
  if(!list) return;
  list.innerHTML = "";

  const items = history.slice(0, 60);
  if(!items.length){
    const p = document.createElement("p");
    p.className = "help";
    p.textContent = "Aucun historique.";
    list.appendChild(p);
    return;
  }

  for(const e of items){
    const row = document.createElement("div");
    row.className = "item";

    const left = document.createElement("div");
    left.className = "t";

    const name = document.createElement("div");
    name.className = "name";
    name.textContent = `${new Date(e.ts).toLocaleString()} ‚Äî ${e.type}`;

    const sub = document.createElement("div");
    sub.className = "sub";
    if(e.type==="task_done"){
      sub.textContent = `${e.title} ¬∑ ${e.cat||""} ¬∑ eth:${e.ethStart||0}`;
    }else if(e.type==="import"){
      sub.textContent = `Import: ${e.count} t√¢ches`;
    }else if(e.type==="set_activated"){
      sub.textContent = `Set: ${e.setName} ¬∑ patients:${e.patients}`;
    }else{
      sub.textContent = JSON.stringify(e).slice(0,140);
    }

    left.appendChild(name);
    left.appendChild(sub);
    row.appendChild(left);
    list.appendChild(row);
  }
}

/* =========================
   Rapport panel
   ========================= */
function buildReportPanel(){
  const wrap = document.createElement("div");

  const c1 = mkCard("Rapport", `
    <p class="help">
      Rapport journalier / hebdo / mensuel (basique mais utile).
      Exporte en JSON (pour tes traitements ult√©rieurs).
    </p>

    <div class="row" style="margin-top:10px;">
      <select id="repRange">
        <option value="day">Aujourd'hui</option>
        <option value="week">7 jours</option>
        <option value="month">30 jours</option>
      </select>
      <button class="btn primary" id="btnMakeReport">G√©n√©rer</button>
    </div>

    <div class="row" style="margin-top:10px;">
      <button class="btn" id="btnExportReport">Exporter</button>
      <button class="btn" id="btnCopyReport">Copier</button>
    </div>

    <textarea id="reportOut" style="margin-top:10px; min-height:220px;" readonly></textarea>
  `);

  wrap.appendChild(c1);

  setTimeout(() => {
    const repRange = document.getElementById("repRange");
    const out = document.getElementById("reportOut");

    let lastReport = null;

    function rangeDays(){
      const v = repRange.value;
      if(v==="day") return 1;
      if(v==="week") return 7;
      return 30;
    }

    function makeReport(){
      const days = rangeDays();
      const cutoff = Date.now() - days*24*3600*1000;

      const ev = history.filter(e => new Date(e.ts).getTime() >= cutoff);

      const doneEv = ev.filter(e => e.type==="task_done");
      const doneTasks = doneEv.length;
      const doneEth = doneEv.reduce((a,b)=>a+(b.ethStart||0),0);

      // remaining snapshot (current state)
      const remainTasks = state.tasks.length;
      const remainEth = sumEth(state.tasks);

      // habits snapshot
      const habitLines = habits.slice(0,50).map(h=>{
        const done = (h.boxes||[]).filter(Boolean).length;
        return { name:h.name, done, total:10, dayISO:h.dayISO };
      });

      lastReport = {
        generatedAt: nowISO(),
        rangeDays: days,
        doneTasks,
        doneEth,
        remaining: { tasks: remainTasks, eth: remainEth },
        doneExamples: doneEv.slice(0,20),
        habits: habitLines,
        activeSet: state.activeSet
      };

      out.value = JSON.stringify(lastReport, null, 2);
    }

    document.getElementById("btnMakeReport").onclick = makeReport;

    document.getElementById("btnExportReport").onclick = () => {
      if(!lastReport) makeReport();
      downloadJSON(`eliminator-report-${todayISO()}.json`, lastReport);
    };

    document.getElementById("btnCopyReport").onclick = async () => {
      if(!lastReport) makeReport();
      try{ await navigator.clipboard.writeText(out.value); }catch(e){}
    };

    makeReport();
  }, 0);

  return wrap;
}

/* =========================
   Params panel
   ========================= */
function buildParamsPanel(){
  const wrap = document.createElement("div");

  const c1 = mkCard("Affichage & comportement", `
    <div class="row">
      <select id="celebrationMode">
        <option value="surprise">C√©l√©brations: surprise</option>
        <option value="frequent">C√©l√©brations: fr√©quentes</option>
        <option value="off">C√©l√©brations: off</option>
      </select>
      <select id="motivation">
        <option value="high">Motivation: haute</option>
        <option value="normal">Motivation: normale</option>
        <option value="low">Motivation: basse</option>
      </select>
    </div>

    <div class="row" style="margin-top:10px;">
      <select id="fatigue">
        <option value="low">Fatigue: faible</option>
        <option value="medium">Fatigue: moyenne</option>
        <option value="high">Fatigue: √©lev√©e</option>
      </select>
      <select id="celebrateHide">
        <option value="6000">Popup: 6s</option>
        <option value="9000">Popup: 9s</option>
        <option value="12000">Popup: 12s</option>
      </select>
    </div>

    <div class="row" style="margin-top:10px;">
      <input id="ethMin" type="number" min="1" max="60" placeholder="Minutes par √©thorion (5)" />
      <button class="btn" id="btnApplyEth">Appliquer</button>
    </div>

    <p class="help" style="margin-top:10px;">
      Par d√©faut: th√®me clair, interface √©pur√©e. Le ‚Äúmode focus‚Äù masque au maximum sans perdre le HUD en haut.
    </p>
  `);

  wrap.appendChild(c1);

  setTimeout(() => {
    const celebrationMode = document.getElementById("celebrationMode");
    const motivation = document.getElementById("motivation");
    const fatigue = document.getElementById("fatigue");
    const celebrateHide = document.getElementById("celebrateHide");
    const ethMin = document.getElementById("ethMin");

    celebrationMode.value = settings.celebrationMode || "surprise";
    motivation.value = settings.motivation || "normal";
    fatigue.value = settings.fatigue || "medium";
    celebrateHide.value = String(settings.celebrationAutoHideMs || 9000);
    ethMin.value = String(settings.ethMinutesPer || 5);

    celebrationMode.onchange = () => { settings.celebrationMode = celebrationMode.value; persistAll(); };
    motivation.onchange = () => { settings.motivation = motivation.value; persistAll(); };
    fatigue.onchange = () => { settings.fatigue = fatigue.value; persistAll(); };
    celebrateHide.onchange = () => { settings.celebrationAutoHideMs = parseInt(celebrateHide.value,10)||9000; persistAll(); };

    document.getElementById("btnApplyEth").onclick = () => {
      settings.ethMinutesPer = clamp(parseInt(ethMin.value,10)||5, 1, 60);
      persistAll();
      renderAll();
    };
  }, 0);

  return wrap;
}

/* =========================
   Export helper
   ========================= */
function downloadJSON(filename, obj){
  const blob = new Blob([JSON.stringify(obj,null,2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

/* =========================
   Wire actions
   ========================= */
btnRoulette.onclick = () => {
  wheel.classList.remove("spin");
  // reflow for animation restart
  void wheel.offsetWidth;
  wheel.classList.add("spin");
  roulette();
  ensureCurrent();
  persistAll();
  renderAll();
};

btnSmash.onclick = () => {
  smashOne();
};

function renderAll(){
  applyTheme();
  applyFocus();
  renderHUD();
  renderMain();
  // refresh list panel if open
  if(activeTab==="liste"){
    setTimeout(() => renderTaskList(), 0);
  }
  if(activeTab==="habits"){
    setTimeout(() => renderHabitsList(), 0);
  }
}

/* =========================
   Init
   ========================= */
function boot(){
  applyTheme();
  applyFocus();

  renderTabs();
  renderPanel();

  // baseline counts if missing
  if(!state.startCounts || !state.startCounts.tasks){
    recalcStartCounts();
  }

  ensureCurrent();
  renderAll();
  startTicker();
}
boot();

</script>
</body>
</html>
